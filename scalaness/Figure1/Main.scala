
import edu.uvm.nest.{Declarations, NesTTypes}
import edu.uvm.scalaness._
import edu.uvm.scalaness.LiftableTypes._

object Main {

  @ModuleType("""{}
                 < addrT <: UInt32; >
                 { ; radio(message: MessageType{src: addrT, dest: addrT, data: Array[UInt8,64]}): ErrorT}""")
  class RadioC extends NesTComponent {
    
    /////////
    // Code generated by the Scalaness compiler.
    /////////
    private var sclnsAddrT: MetaType[UInt32] = null

    def instantiate(addrT: MetaType[UInt32]) = {
      sclnsAddrT = addrT
      this
    }

    // private val abstractSyntax = Parser.reparse("Radio.nc", List("addrT"))
      
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "RadioC",              // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set("addrT"),          // TODO: Obtain from class MetaType parameters.
        valueParameters = Set(),                 // TODO: Obtain from class value parameters.
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("addrT" -> sclnsAddrT)
    def getValueMap = Map[String, Any]()
    ////////
    // END of Scalaness generated code.
    //////// 

    "RadioC.nt"
  }


  @ModuleType("""{}
                 < addrT <: UInt32; >
                 { radio(message: MessageType{src: addrT, dest: addrT, data: Array[UInt8,64]}): ErrorT;
                   send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT }""")
  class SendC extends NesTComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    private var sclnsAddrT: MetaType[UInt32] = null

    def instantiate(addrT: MetaType[UInt32]) = {
      sclnsAddrT = addrT
      this
    }

    // private val abstractSyntax = Parser.reparse("SendC.nc", List("addrT"))
      
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "SendC",               // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set("addrT"),          // TODO: Obtain from class MetaType parameters.
        valueParameters = Set(),                 // TODO: Obtain from class value parameters.
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("addrT" -> sclnsAddrT)
    def getValueMap = Map[String, Any]()
    ////////
    // END of Scalaness generated code.
    //////// 

    "SendC.nt"
  }

  @ModuleType("""{}
                 < addrT <: UInt32; self: UInt32, neighbor: UInt32 >
                 { send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT;
                   main(): ErrorT }""")
  class NodeC extends NesTComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    private var sclnsAddrT   : MetaType[UInt32] = null
    private var sclnsSelf    : UInt32 = null
    private var sclnsNeighbor: UInt32 = null

    def instantiate(addrT: MetaType[UInt32], self: UInt32, neighbor: UInt32) = {
      sclnsAddrT    = addrT
      sclnsSelf     = self
      sclnsNeighbor = neighbor
      this
    }

    // private val abstractSyntax = Parser.reparse("NodeC.nc", List("addrT"))
      
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "NodeC",                 // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set("addrT"),            // TODO: Obtain from class MetaType parameters.
        valueParameters = Set("self", "neighbor"), // TODO: Obtain from class value parameters.
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("addrT" -> sclnsAddrT)
    def getValueMap = Map("self" -> sclnsSelf, "neighbor" -> sclnsNeighbor)
    ////////
    // END of Scalaness generated code.
    //////// 

    "NodeC.nt"
  }

  def nodeSpecialize(
    self    : UInt32,
    neighbor: UInt32,
    nmax    : Int,
    @ModuleType(
      """{}< addrT <: UInt32; >{ ;
           radio(message: MessageType{src: addrT, dest: addrT, data: Array[UInt8,64]}): ErrorT}""") rawRadioC: RadioC) = {
           
    val SendT = new TypeAbbreviation("""{}
                   < addrT <: UInt32; >
                   { radio(message: MesgType): ErrorT;
                     send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT }""",
                     List("MesgType"))
    val ScodeT = new TypeAbbreviation("""{ addrT <: UInt32 }<;>{
                     ;
                     send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT}""", List())
    val NodeT = new TypeAbbreviation("""{}
                   < addrT <: UInt32; self: UInt32, neighbor: UInt32 >
                   { send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT;
                     main(): ErrorT }""", List())
    val McodeT = new TypeAbbreviation("""{ addrT <: UInt32 }
                   <;>
                   { send(s: addrT, d: addrT, data: Array[UInt8]): ErrorT;
                     main(): ErrorT}""",List())

    val addrt: MetaType[UInt32] =
      if (nmax < 256) new MetaType[UInt32](NesTTypes.UInt8)
        else new MetaType[UInt32](NesTTypes.UInt16)

    @TypeAbbr(SendT.parameterize(List("MessageType{src: addrT, dest: addrT, data: Array[UInt8,64]}")))
    val rawSendC = new SendC
    

    @TypeAbbr(ScodeT)
    val scode = (rawSendC.instantiate(addrt)) +> rawRadioC.instantiate(addrt)
    // Extra parentheses around first component above intentional. Does it work?

    @TypeAbbr(NodeT)
    val rawNodeC = new NodeC

    @TypeAbbr(McodeT)
    val mcode = rawNodeC.instantiate(addrt, self, neighbor)

    (mcode +> scode).image
  }


  /**
   * The main method allows the code above to be executed and generates a residual program.
   */
  def main(args: Array[String]) {
    if (args.length != 1) {
      println("Usage: Main network-size")
    }
    else {
      val networkSize = args(0).toInt
      @ModuleType("""{}
                     < addrT <: UInt32; >
                     { ;
                       radio(message: MessageType{src: addrT, dest: addrT, data: Array[UInt8,64]}): ErrorT}""")
      val uninstantiatedRadio = new RadioC
      nodeSpecialize(
        self      = new UInt32(1),  // Hard code our address (for now).
        neighbor  = new UInt32(2),  // Hard code the neighbor address (for now).
        nmax      = networkSize,
        rawRadioC = uninstantiatedRadio)
    }
  }

}
