<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="IML.xsl"?>

<issue-set xmlns="http://vortex.cis.vtc.edu/xml/IML_0.0"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://vortex.cis.vtc.edu/xml/IML_0.0 IML.xsd">

  <issue>
    <summary>Create a method to pretty print Mininess types</summary>
    <creation-date>
      <date>2011-06-14</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-06-14</date>
        </comment-date>
        <notes>
          <xhtml:p>The representation of Mininess types is currently abstract (a collection of
            case objects and case classes). This is fine for internal use but it is ugly to
            display. It would be nice to have a method that converts the abstract representation
            of a Mininess type into something that looks more like the way types are written in
            Mininess programs. For example we want something like</xhtml:p>

          <xhtml:pre>Array(Pointer(UInt8), 10)</xhtml:pre>

          <xhtml:p>to be displayed as</xhtml:p>

          <xhtml:pre>uint8_t *[10]</xhtml:pre>

          <xhtml:p>Fully correct handling of this conversion might be tricky due to the somewhat
            odd syntax of types used by C like languages. It should be relatively easy, however,
            to get an approximately correct version of the method. I expect this method will be
            useful in error and debug messages produced by the Scalaness compiler.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Mininess type checking should continue after first type error</summary>
    <creation-date>
      <date>2011-07-25</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-07-25</date>
        </comment-date>
        <notes>
          <xhtml:p>Right now the first error found during the type checking of Mininess
            inclusions causes an exception to be thrown and the checking to abort. It would be
            better if the type checking continued after the first error to see if there are more
            errors. Implementing this will be a little tricky. In the case of undefined symbols
            it will be necessary to guess what type the symbols should have so they can be
            reasonably checked when used later.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Mininess parsing should continue after the first syntax error</summary>
    <creation-date>
      <date>2011-07-25</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-07-25</date>
        </comment-date>
        <notes>
          <xhtml:p>Right now the first syntax error found during the parsing of a Mininess
            inclusion causes the parse to abort. It is traditional for compilers to attempt a
            correction and then continue parsing to search for additional errors. The Scalaness
            compiler should do the same.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Mininess return statements should be type checked against the declared return type</summary>
    <creation-date>
      <date>2011-11-28</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-11-28</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently return statements are type checked as Some(Okay) provided the
            expression being returned is Okay. However, the type checker should verify that the
            type being returned actually agrees with the declared type of the enclosing
            function/command/event.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Objects and classes representing Mininess modules must extend MininessComponent</summary>
    <creation-date>
      <date>2012-02-27</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2012-02-27</date>
        </comment-date>
        <notes>
          <xhtml:p>Right now any class or module with a primary constructor ending with a string
            literal is treated as a wrapper around a Mininess inclusion. However, the intention
            is for all such classes or modules to also extend the trait MininessComponent. This
            trait contains essential runtime support for manipulating Mininess modules; its
            presence should be verified. In particularly only classes (or modules) that extend
            MininessComponent should be searched for Mininess inclusions and, furthermore, it
            should be a compile time error if no inclusion is found in such a class or
            module.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Store ASTs of Mininess components in the executable jar</summary>
    <creation-date>
      <date>2011-05-16</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-05-16</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently the Mininess templates are stored in the executable jar as raw
            source files. This requires the runtime system to reparse them during the execution
            of the Scalaness program. The main issue with that is it requires ANTLR to be
            available to the runtime system. Since the Mininess templates must be parsed during
            compilation (for type checking) it might be nice to instead store them as serialized
            ASTs in the executable jar file. This would avoid reparsing the source at runtime
            and ANTLR would not needed.</xhtml:p>

          <xhtml:p>This ticket is a low priority enhancement.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>The type of the literal -128 is incorrect</summary>
    <creation-date>
      <date>2011-08-21</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2011-08-21</date>
        </comment-date>
        <notes>
          <xhtml:p>The specification of Mininess in the Scalaness User Documentation says that
            the negative sign when applied to an integer literal is part of the literal. That is
            '-128' is a single token and not the '-' token followed by the '128' token. This is
            important because otherwise -128 will have type int16_t rather than int8_t as it
            should. In particular '128' must have type int16_t since 128 is too large to
            represent with int8_t. With the '-' sign as part of the literal token the compiler
            can see that '-128' is a legal int8_t value and assign it an appropriate
            type.</xhtml:p>

          <xhtml:p>The Scalaness compiler currently does not handle this properly. The ANTLR
            grammar needs to be changed to deal with negative literals directly.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Relative paths in the Scalaness configuration file should be relative to the file's location</summary>
    <creation-date>
      <date>2013-02-07</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2013-02-07</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently some configuration items in the Scalaness configuration files are
            paths to other files or folders. If those paths are relative they are taken relative
            to the compiler's working directory. They should instead be taken as relative to the
            file's location. Some IDEs (such as IntelliJ) execute the compiler from the
            compiler's installation folder which is usually very far away from the folder
            containing the project. This makes it necessary to use absolute paths in the
            Scalaness configuration file, which is fragile and not very version control
            friendly.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Syntax errors in ModuleType annotations should have their location reported.</summary>
    <creation-date>
      <date>2013-02-08</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2013-02-08</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently if there is a syntax error in a ModuleType annotation the error is
            reported by not its location. This makes fixing such errors harder than it should
            be. It would be better if the location was reported as for other kinds of syntax
            errors.</xhtml:p>

          <xhtml:p>Dealing with this will be a bit tricky. ANTLR reports the error location
            relative to the string it is parsing. That location will need to be converted into
            an offset in the enclosing source file before the Scala compiler's error reporter
            will be able to handle it.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Syntax errors in interfaces parsed during interface unwrapping should be reported relative to the proper file.</summary>
    <creation-date>
      <date>2013-02-08</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2013-02-08</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently if there is a syntax error in an interface that is being parsed
            during interface unwrapping, the syntax error location is reported relative to the
            main source file being processed and not the interface file. This leads to very
            misleading error messages (they point at a totally unrelated location).</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Should external structures and external types be supported in Mininess?</summary>
    <creation-date>
      <date>2013-02-10</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2013-02-10</date>
        </comment-date>
        <notes>
          <xhtml:p>The <code>nx_struct</code> structures and related types are currently outside
            the Mininess subset. It might be useful to include them. Doing so would involve
            changing the Mininess type checker and maybe also the declaration and symbol table
            handling of Mininess code. Allowing such types in imports and exports would also
            require adjustments to the ModuleType annotation syntax and associated processing.
            Thus this change has a significant ripple effect and shouldn't be undertaken too
            lightly.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>

  <issue>
    <summary>Unknown configuration items should not cause the compiler to crash.</summary>
    <creation-date>
      <date>2013-02-11</date>
    </creation-date>
    <comments>
      <comment>
        <reporter>Peter Chapin</reporter>
        <comment-date>
          <date>2013-02-11</date>
        </comment-date>
        <notes>
          <xhtml:p>Currently if the compiler discovers an unrecognized configuration setting in
            the Scalaness configuration file, it throws and unhandled exception and crashes.
            This is clearly inelegant.</xhtml:p>
        </notes>
      </comment>
    </comments>
  </issue>
</issue-set>
