//-----------------------------------------------------------------------
// FILE    : Main.scala
// SUBJECT : The main object for the Scalaness Checksum sample.
// AUTHOR  : (C) Copyright 2012 by Peter Chapin <PChapin@vtc.vsc.edu>
//
//-----------------------------------------------------------------------

object Main {

  import edu.uvm.mininess._
  import edu.uvm.scalaness._
  import LiftableTypes._

  class ChecksumC extends MininessComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    private var sclnsSize: UInt16 = null
    private var sclnsChecksumType: MetaType[UInt32] = null

    def instantiate(size: UInt16, checksumType: MetaType[UInt32]) = {
      sclnsSize = size
      sclnsChecksumType = checksumType
      this
    }

    private val abstractSyntax = Parser.reparse("ChecksumC.nc", List("checksumType"))
      
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "ChecksumC",           // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set("checksumType"),   // TODO: Obtain from class MetaType parameters.
        valueParameters = Set("size"),           // TODO: Obtain from class value parameters.
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("checksumType" -> sclnsChecksumType)
    def getValueMap = Map("size" -> sclnsSize)
    ////////
    // END of Scalaness generated code.
    //////// 
           
    "ChecksumC.nc"
  }
 

  class MessageFormatterC extends MininessComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    private var sclnsSize: UInt16 = null
    private var sclnsChecksumType: MetaType[UInt32] = null

    def instantiate(size: UInt16, checksumType: MetaType[UInt32]) = {
      sclnsSize = size
      sclnsChecksumType = checksumType
      this
    }

    private val abstractSyntax  =
      Parser.reparse("MessageFormatterC.nc", List())
    
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "MessageFormatterC",
        enclosingObject = this,
        typeParameters  = Set(),
        valueParameters = Set("size"),
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map()
    def getValueMap = Map("size" -> sclnsSize)
    ////////
    // END of Scalaness generated code.
    ////////
         
    "MessageFormatterC.nc"
  }


  def getSize = {
    // Compute a size based on runtime information.
    new UInt16(128)
  }


  @ModuleType("""{checksumType <: UInt32}
                 <;>
                 { ; compute_checksum(data: UInt32): checksumType}""")
  def getChecksummer(size: UInt16, checksumType: MetaType[UInt32]) = {
    // Create and instantiate an appropriate nesT checksumming module.
    (new ChecksumC).instantiate(size, checksumType)
    
  }
 
    
  /**    
   * @param args The command line arguments
   */ 
  def main(args: Array[String]) {
    val desiredChecksumType: MetaType[UInt32] = Integer.parseInt(args(0)) match {
      case  8 => 
        println("Selecting 8 bit checksums")   
        new MetaType[UInt32](MininessTypes.UInt8)
        
      case 16 =>
        println("Selecting 16 bit checksums") 
        new MetaType[UInt32](MininessTypes.UInt16)

      case 32 =>
        println("Selecting 32 bit checksums")
        new MetaType[UInt32](MininessTypes.UInt32)
    }
    
    val size = getSize

    @ModuleType("""{ }
                   <;>
                   { compute_checksum(data: UInt32): checksumType; }""")
    val formattingModule = (new MessageFormatterC).instantiate(size, desiredChecksumType)

    @ModuleType("""{checksumType <: UInt32}
                   <;>
                   { ; }""")
    val resultModule = formattingModule +> getChecksummer(size, desiredChecksumType)
    resultModule.validate()
  }
    
}       
