//-----------------------------------------------------------------------
// FILE    : Main.scala
// SUBJECT : The main object for the Scalaness Checksum sample.
// AUTHOR  : (C) Copyright 2012 by Peter Chapin <PChapin@vtc.vsc.edu>
//
//-----------------------------------------------------------------------

object Main {

  import edu.uvm.nest._
  import edu.uvm.scalaness._
  import LiftableTypes._ 

  // The Scalaness representation of the nesC Library's imports.
  @ModuleType("""{}
                 <;>
                 { booted(): Void,
                   fired(): Void; }""")
  object LibraryIC extends NesTComponent {
    /////////
    // Code generated by the Scalaness compiler.
    /////////
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "LibraryIC",   // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set(),         // TODO: Obtain from class MetaType parameters.
        valueParameters = Set(),         // TODO: Obtain from class value parameters.
        imports         = Set("booted", "fired"),
        exports         = Set(),
        abstractSyntax  = null), "generated")
    
    def getTypeMap  = Map()
    def getValueMap = Map()
    ////////
    // END of Scalaness generated code.
    //////// 

    external("LibraryIC.nc")
  }


  // The Scalaness representation of the nesC Library's exports.
  @ModuleType("""{}
                 <;>
                 { ; startPeriodic(period: UInt32): Void }""")
  object LibraryEC extends NesTComponent {
    /////////
    // Code generated by the Scalaness compiler.
    /////////
    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "LibraryEC",   // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set(),         // TODO: Obtain from class MetaType parameters.
        valueParameters = Set(),         // TODO: Obtain from class value parameters.
        imports         = Set(),
        exports         = Set("startPeriodic"),
        abstractSyntax  = null), "generated")
    
    def getTypeMap  = Map()
    def getValueMap = Map()
    ////////
    // END of Scalaness generated code.
    //////// 

    external("LibraryEC.nc")
  }


  // A component for computing checksums.
  @ModuleType("""{}
                 < checksumType <: UInt32; size: UInt16 >
                 { ; compute_checksum(data: Array[UInt8]): checksumType }""")
  class ChecksumC extends NesTComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    def instantiate(size: UInt16, checksumType: MetaType[UInt32]) = {
      val result = new ChecksumC
      result.sc_size = size
      result.sc_checksumType = checksumType
      result
    }

    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "ChecksumC",           // TODO: Extract from AST.
        enclosingObject = this,
        typeParameters  = Set("checksumType"),   // TODO: Obtain from class MetaType parameters.
        valueParameters = Set("size"),           // TODO: Obtain from class value parameters.
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("checksumType" -> sc_checksumType)
    def getValueMap = Map("size" -> sc_size)
    ////////
    // END of Scalaness generated code.
    //////// 
           
    "ChecksumC.nt"
  }
 

  // A component for creating messages.
  @ModuleType("""{}
                 < checksumType <: UInt32; size: UInt16 >
                 { compute_checksum(data: Array[UInt8]): checksumType,
                   startPeriodic(period: UInt32): Void;
                   booted(): Void,
                   fired(): Void }""")
  class MessageFormatterC extends NesTComponent {

    /////////
    // Code generated by the Scalaness compiler.
    /////////
    def instantiate(size: UInt16, checksumType: MetaType[UInt32]) = {
      val result = new MessageFormatterC
      result.sc_size = size
      result.sc_checksumType = checksumType
      result
    }

    val configuration =
      new ProgramComponentWrapper(new NamedProgramComponent(
        name            = "MessageFormatterC",
        enclosingObject = this,
        typeParameters  = Set("checksumType"),
        valueParameters = Set("size"),
        imports         = Declarations.extractImports(abstractSyntax),
        exports         = Declarations.extractExports(abstractSyntax),
        abstractSyntax  = abstractSyntax), "generated")
    
    def getTypeMap  = Map("checksumType" -> sc_checksumType)
    def getValueMap = Map("size" -> sc_size)
    ////////
    // END of Scalaness generated code.
    ////////
         
    "MessageFormatterC.nt"
  }


  /**
   * The following method returns a fully instantiated nesT component for computing checksums.
   * The precise component created depends on runtime information.
   *
   * @param size The size of the data block the component will process.
   * @checksumType The type used for the final checksum.
   */
                 
  def getChecksummer(size: UInt16, checksumType: MetaType[UInt32]) = {
  
    @ModuleType("""{}
                 < checksumType <: UInt32; size: UInt16 >
                 { ; compute_checksum(data: Array[UInt8]): checksumType }""")
    val CheckSummer = new ChecksumC
    
    @ModuleType("""{ checksumType <: UInt32 }
                 <;>
                 { ; compute_checksum(data: Array[UInt8]): checksumType }""")
    val instCheckSummer = CheckSummer.instantiate(size, checksumType)
    
    instCheckSummer
    
  }

    
  /**
   * The main method obtains configuration information from the command line and composes the
   * final program accordingly.
   * 
   * @param args The command line arguments
   */ 
  def main(args: Array[String]) {
  
    val MesgT = new TypeAbbreviation("""{}
                 < checksumType <: UInt32; size: UInt16 >
                 { startPeriodic(period: UInt32): Void,
                   compute_checksum(data: Array[UInt8]): checksumType;
                   fired(): Void,
                   booted(): Void }""",List())
                   
    val FormT = new TypeAbbreviation("""{ checksumType <: UInt32 }
                     <;>
                     { compute_checksum(data: Array[UInt8]): checksumType,
                       startPeriodic(period: UInt32): Void;
                       booted(): Void,
                       fired(): Void }""",List())
                       
    val CheckT = new TypeAbbreviation("""{ checksumType <: UInt32 }
                 <;>
                 { ; compute_checksum(data: Array[UInt8]): checksumType }""",List())
                      
    val WireT = new TypeAbbreviation("""{ checksumType <: UInt32 }
                 <;>
                 { startPeriodic(period: UInt32): Void; 
                   booted(): Void,
                   fired(): Void  }""",List())
                   
    val ResultT = new TypeAbbreviation("""{ checksumType <: UInt32 }
                     <;>
                     { ; }""",List())

    def getChecksumType(args: Array[String]) = {
      args(0).toInt match {
        case  8 => 
          println("Selecting 8 bit checksums")   
          new MetaType[UInt8](NesTTypes.UInt8)
        
        case 16 =>
          println("Selecting 16 bit checksums") 
          new MetaType[UInt32](NesTTypes.UInt16)

        case 32 =>
          println("Selecting 32 bit checksums")
          new MetaType[UInt32](NesTTypes.UInt32)
      }
    }

    def getSize(args: Array[String]) = {
      val size = args(1).toInt
      println(s"Selecting $size byte message blocks")
      new UInt16(size)
    }

    if (args.length != 2) println("Usage: Main checksum_bit_length block_size")
    else {
    
      val desiredChecksumType = getChecksumType(args)
      val desiredSize = getSize(args)
      
      @TypeAbbr(MesgT)
      val MessageFormatter = new MessageFormatterC

      @TypeAbbr(FormT)
      val formattingModule = MessageFormatter.instantiate(desiredSize, desiredChecksumType)
                 
      @TypeAbbr(CheckT)
      val checkingModule = getChecksummer(desiredSize, desiredChecksumType)
      
      @TypeAbbr(WireT)
      val wireModule = formattingModule +> checkingModule
      
      @TypeAbbr(ResultT)
      val resultModule = LibraryIC +> formattingModule +> checkingModule +> LibraryEC
      
      resultModule.image()

    }
  }
    
}       
