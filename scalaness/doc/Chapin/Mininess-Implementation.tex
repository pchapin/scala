\chapter{Mininess Implementation}
\label{chapter-mininess-implementation}

\lstset{language=nesC}
\lstMakeShortInline!

Mininess is implemented as a rewritting to ordinary nesC. Since Mininess is approximately a
subset of nesC this rewriting is largely trivial. However, certain aspects of Mininess are
different than nesC, in particular structure subtyping, safe casts, and array operations. In
this section I describe in detail how these features are rewritten.

\section{Component Specifications}
\label{section-component-specifications-implementation}

\note{Include something useful here}

\section{Structure Subtyping}
\label{section-structure-subtyping-implementation}

\note{Include something useful here}

\section{Safe Casts}
\label{section-safe-casts-implementation}

Initialization and assignments are implicitly allowed if the expression on the right hand side
of the operation has a subtype of the l-value on the left hand side. Actual type conversions
(casts) must all be explicit and are only allowed as provided by user configuration described in
\autoref{section-safe-casts-design}.

To illustrate the way these casts are implemented in Mininess programs consider as an example
the following two structure definitions.

\singlespace
\begin{lstlisting}[language=nesC]
struct UserInfo {
    char name[25];
    int  age;
    int  id;
};

struct UserToken {
    int id;
    int hash;
};
\end{lstlisting}
\primaryspacing

The developer may wish to allow an object of type !UserInfo! to be explicitly cast into an
object of type !UserToken!. Once the Scalaness compiler determines that this is legal it
rewrites each cast expression into a call of an appropriately named conversion command. These
conversion commands exist in an interface !DoCast!. For example

\singlespace
\begin{lstlisting}[language=nesC]
token = (struct UserToken)user;

// ... rewritten to ...

token = (call DoCast.UserInfo_UserToken(user));
\end{lstlisting}
\primaryspacing

The developer is required to provide the !DoCast! interface and a component !DoCastC! that
provides that interface and contains an implementation of the various conversion commands
needed.

% TODO: What about conversions between types that are type parameters?

\section{Array Operations}
\label{section-array-operations-implementation}

Each expression !a! of array type !Array(T)! has a corresponding hidden dynamic value
representing the size of the array. Expressions of the form !a |> e! can nominally be rewritten
to nesC using pointer arithmetic as !( (a) + (e) )!. Let $n$ be the dynamic size of expression
!a!, then $n_e$ the dynamic size of !a |> e! is $n_e = n - e$. This size might be negative but
any use of an array expression with a negative size results in a run time error \emph{at the
  point of use}.

A statement containing one or more array increment expressions or array indexing expressions is
rewritten as a block enclosed sequence of statements containing compiler generated local
variables for the dynamic sizes of the temporary arrays along with appropriate run time checks.

For each array increment operation $a_i \rhd e_i$ in a statement a variable to hold the value of
$e_i$ is declared and initialized. This is done so that $e_i$ will only be evaluated once; an
important considering in a language, such as nesC, with side effects. Also the dynamic size of
the result of each array operation $d_i$ is declared and initialized appropriately. For example

\singlespace
\begin{lstlisting}[language=nesC]
... (a |> e) ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e;
  int __d_1 = __d_0 - __e_1;

  ... ((a) + __e_1) ...
}
\end{lstlisting}
\primaryspacing

Here !__d_0! is the dynamic size associated with the array expression !a!. In the common case
where !a! is a declared array the size will be known statically and an appropriate constant can
be used instead of a reference to a dynamic size variable.

For each array indexing operation $a_i[e_i]$ in a statement a variable to hold the value of
$e_i$ is declared and initialized, as before. A run time check is inserted to ensure that
the value of $e_i$ is inside the dynamic size of $a_i$. For example

\singlespace
\begin{lstlisting}[language=nesC]
... a[n] ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = n;
  if (__e_1 >= __d_0) error( );
  ... a[__e_1] ...
}
\end{lstlisting}
\primaryspacing

As before !__d_0! is the dynamic size associated with the array expression !a!.

In a statement involving multiple array operations, each operation is rewritten as described
above one at a time. After the first operation is rewritten, the enclosed modified statement is
further expanded with the second rewriting. The checks are issues in the order they are
encountered during a depth first left to right traversal of the Mininess abstract syntax tree.
For example a statement such as

\singlespace
\begin{lstlisting}[language=nesC]
x = ((a |> e1) |> e2)[b[i]];
\end{lstlisting}
\primaryspacing

Is first rewritten as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  x = (((a) + __e_1) |> e2)[b[i]];
}
\end{lstlisting}
\primaryspacing

The resulting statement still contains three array operations. The second stage of rewriting
yields

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    x = ( ((a) + __e_1) + __e_2 )[b[i]];
  }
}
\end{lstlisting}
\primaryspacing

The inner indexing operation is then rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      x = ( ((a) + __e_1) + __e_2 )[b[__e_3]];
    }
  }
}
\end{lstlisting}
\primaryspacing

Finally, the outer indexing operation is rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      {
        int __e_4 = b[__e_3];
        if (__e_4 >= __d_2) error( );
        x = ( ((a) + __e_1) + __e_2 )[__e_4];
      }
    }
  }
}
\end{lstlisting}
\primaryspacing

% Notice that declarations can't be enclosed in the block without changing the scope of the
% identifiers they declare. Thus array expressions used in the initialization of a variable
% present a special problem. It might be necessary to first split initializers off from their
% declarations in a separate AST processing pass.

Functions declared to take an array as a parameter are rewritten to so that the dynamic size of
the array is passed as an additional parameter. This parameter becomes the $d$ of array
expressions involving only the parameter. Calls to such functions are rewritten to pass the
additional dynamic size information as appropriate.

% TODO: Need to talk about how the errors are handled.

\lstDeleteShortInline!

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
