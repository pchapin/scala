\chapter{Mininess Implementation}
\label{chap:mininess-implementation}

Mininess is implemented as a rewritting to ordinary nesC. Since Mininess is approximately a
subset of nesC this rewriting is largely trivial. However, certain aspects of Mininess are
different than nesC, in particular component specifications, structure subtyping, and array
operations. In this section I describe in detail how these features are rewritten.

\section{Component Specifications}
\label{sec:component-specifications-implementation}

\note{Including something useful here}

\subsection{External Libraries}
\label{sec:external-libraries-implementation}

\note{I need a little more introduction.} The Scalaness compiler parses the component
specification of the external component and unwraps the interfaces used and provided by that
component. For each such interface the Scalaness compiler generates a shim module that forwards
Mininess commands to the full nesC interface. When generic interfaces are used by the external
component these shim modules are themselves generic.

\autoref{figure-shim-modules} shows the shims generated for a library component
\inlinecode{LibraryC} that uses interface \inlinecode{U} and provides interface \inlinecode{P}.

\singlespace
\begin{fpfig}[tbhp]{Shim Modules}{figure-shim-modules}
{
\begin{lstlisting}[language=nesC]
module Sclnss_U1 {
  provides interface U;
  uses     command void Uc(int);
  provides command void Ue(int);
}
implementation {
  command void Ue(int i)
    { signal U.Ue(i); }

  command void U.Uc(int i)
    { call Uc(i); }
}

module Sclnss_P1 {
  uses     interface P;
  provides command void Pc(int i);
  uses     command void Pe(int i);
}
implementation {
  event void P.Pe(int i)
    { call Pe(i); }

  command void Pc(int i)
    { call P.Pc(i); }
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

The precise names used for these components are internal identifiers generated by Scalaness and
are not intended to be used by the programmer. Instead Scalaness wraps the original library
component and the shims into a configuration as shown in \autoref{figure-library-configuration}.
If the original component was generic or used generic interfaces, then the wrapping
configuration is also generic so that it properly corresponds to its representation in
Scalaness.

\singlespace
\begin{fpfig}[tbhp]{Configuration Wrapping Library Component}{figure-library-configuration}
{
\begin{lstlisting}[language=nesC]
configuration Sclnss_LibraryC {
  uses     command void Uc(int);
  provides command void Ue(int);
  provides command void Pc(int);
  uses     command void Pe(int);
}
implementation {
  components Sclnss_P1, Sclnss_U1, LibraryC;
  LibraryC.U  -> Sclnss_U1;
  Sclnss_P1.P -> LibraryC;

  Sclnss_P1.Pe -> Pe;
  Pc -> Sclnss_P1.Pc;
  
  Sclnss_U1.Uc -> Uc;
  Ue -> Sclnss_U1.Ue;
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

In effect the Scalaness compiler automatically converts an external library component into a
Mininess component that can be manipulated by the first stage program. The Scalaness compiler
extracts a module type for the component, based on its imports and exports, as usual. The
component can then participate in the process of component composition allowed by the Scalaness
language.

In the current implementation the Scalaness compiler does not attempt to type check the external
library component. Presumably external components have been previously well tested. In effect,
Scalaness treats them as entirely static; staging is only applied to a portion of the final
application and to its overall configuration.

% So it's possible to use an external generic component that fails for certain instantiations
% and Scalaness won't notice that. Fixing this would entail extending the type system to cover
% full nesC since the contents of the external components are \emph{not} Mininess.

As I've described so far each external library component is wrapped in a separate configuration.
However, a programmer could create a larger configuration of library components manually and
then treat that entire configuration as a single entity inside the Scalaness program. The choice
depends on the amount of control the programmer wants the first stage program to have on how
library components are specified and composed. In some applications it may make sense for an
entire subsystem of library components to be configured into a single entity ahead of time. In
other applications the programmer may wish to control library configuration as part of the first
stage execution.

\section{Structure Subtyping}
\label{sec:structure-subtyping-implementation}

\section{Safe Casts}
\label{sec:safe-casts-implementation}

Initialization and assignments are implicitly allowed if the expression on the right hand side
of the operation has a subtype of the l-value on the left hand side. Actual type conversions
(casts) must all be explicit and are only allowed as provided by user configuration described in
Section~\ref{sec:safe-casts-design}.

To illustrate the way these casts are implemented in Mininess programs consider as an example
the following two structure definitions.

\singlespace
\begin{lstlisting}[language=nesC]
struct UserInfo {
    char name[25];
    int  age;
    int  id;
};

struct UserToken {
    int id;
    int hash;
};
\end{lstlisting}
\primaryspacing

The developer may wish to allow an object of type \texttt{UserInfo} to be explicitly cast into
an object of type \texttt{UserToken}. Onc the Scalaness compiler determins that this is legal it
rewrites each cast expression into an explicit call of an appropriately named conversion
command. These conversion commands exist in an interface \texttt{DoCast}. For example

\singlespace
\begin{lstlisting}[language=nesC]
token = (struct UserToken)user;

// ... rewritten to ...

token = (call DoCast.UserInfo_UserToken(user));
\end{lstlisting}
\primaryspacing

The developer is required to provide the \texttt{DoCast} interface and a component
\texttt{DoCastC} that provides that interface and contains an implementation of the various
conversion commands needed.

% TODO: What about conversions between types that are type parameters?

\section{Array Operations}
\label{sec:array-operations-implementation}

Each expression \texttt{a} of array type \texttt{Array(T)} has a corresponding hidden dynamic
value representing the size of the array. Expressions of the form \texttt{a |> e} can nominally
be rewritten to nesC using pointer arithmetic as \texttt{( (a) + (e) )}. Let $n$ be the dynamic
size of expression \texttt{a}, then $n_e$ the dynamic size of \texttt{a |> e} is $n_e = n - e$.
This size might be negative but any use of an array expression with a negative size results in a
run time error \emph{at the point of use}.

A statement containing one or more array increment expressions or array indexing expressions is
rewritten as a block enclosed sequence of statements containing compiler generated local
variables for the dynamic sizes of the temporary arrays along with appropriate run time checks.

For each array increment operation $a_i \rhd e_i$ in a statement a variable to hold the value of
$e_i$ is declared and initialized. This is done so that $e_i$ will only be evaluated once; an
important considering in a language with side effects. Also the dynamic size of the result of
each array operation $d_i$ is declared and initialized appropriately. For example

\singlespace
\begin{lstlisting}[language=nesC]
... (a |> e) ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e;
  int __d_1 = __d_0 - __e_1;

  ... ((a) + __e_1) ...
}
\end{lstlisting}
\primaryspacing

Here \texttt{\_\_d\_0} is the dynamic size associated with the array expression \texttt{a}. In
the common case where \texttt{a} is a declared array the size will be known statically and an
appropriate constant can be used instead of a reference to a dynamic size variable.

For each array indexing operation $a_i[e_i]$ in a statement a variable to hold the value of
$e_i$ is declared and initialized, as before. A run time check is inserted to ensure that
the value of $e_i$ is inside the dynamic size of $a_i$. For example

\singlespace
\begin{lstlisting}[language=nesC]
... a[n] ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = n;
  if (__e_1 >= __d_0) error( );
  ... a[__e_1] ...
}
\end{lstlisting}
\primaryspacing

As before \texttt{\_\_d\_0} is the dynamic size associated with the array expression \texttt{a}.

In a statement involving multiple array operations, each operation is rewritten as described
above one at a time. After the first operation is rewritten, the enclosed modified statement is
further expanded with the second rewriting. The checks are issues in the order they are
encountered during a depth first left to right traversal of the Mininess abstract syntax tree.
For example a statement such as

\singlespace
\begin{lstlisting}[language=nesC]
x = ((a |> e1) |> e2)[b[i]];
\end{lstlisting}
\primaryspacing

Is first rewritten as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  x = (((a) + __e_1) |> e2)[b[i]];
}
\end{lstlisting}
\primaryspacing

The resulting statement still contains three array operations. The second stage of rewriting
yields

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    x = ( ((a) + __e_1) + __e_2 )[b[i]];
  }
}
\end{lstlisting}
\primaryspacing

The inner indexing operation is then rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      x = ( ((a) + __e_1) + __e_2 )[b[__e_3]];
    }
  }
}
\end{lstlisting}
\primaryspacing

Finally, the outer indexing operation is rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      {
        int __e_4 = b[__e_3];
        if (__e_4 >= __d_2) error( );
        x = ( ((a) + __e_1) + __e_2 )[__e_4];
      }
    }
  }
}
\end{lstlisting}
\primaryspacing

% Notice that declarations can't be enclosed in the block without changing the scope of the
% identifiers they declare. Thus array expressions used in the initialization of a variable
% present a special problem. It might be necessary to first split initializers off from their
% declarations in a separate AST processing pass.

Functions declared to take an array as a parameter are rewritten to so that the dynamic size of
the array is passed as an additional parameter. This parameter becomes the $d$ of array
expressions involving only the parameter. Calls to such functions are rewritten to pass the
additional dynamic size information as appropriate.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
