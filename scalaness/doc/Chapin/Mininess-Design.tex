
\chapter{Mininess Design}
\label{chap:mininess-design}

\section{Component Specifications}
\label{sec:component-specifications-design}

In Mininess components (after specialization) present interfaces that are sequences of imports
and exports. The imports are implemented as nesC commands that are ``used'' by the component and
the exports are implemented as nesC commands that are ``provided'' by the component. NesC style
events are not part of Mininess but can be simulated using commands.

% TODO: The citation below should really be to the nesC specification.

Mininess also does not provide separate interfaces as nesC does. Instead all interaction with
other components is done by way of separately declared commands. These bare commands can be
wired together in the usual way by the nesC compiler \cite{Gay-nesC-2003}. This approach follows
the theoretical development in \cite{FramedML,nesT}.

% TODO: Show an example Mininess component with bare commands used and provided.

\subsection{External Libraries}
\label{sec:external-libraries-design}

My experiments with Mininess show that it is expressive enough to write useful program
components. However, any realistic application will need to interact with various libraries
written in full nesC that I call \newterm{external libraries}. It is not my intention to require
the whole program be generated by Scalaness. One external library of critical importance is the
TinyOS operating system itself.

I provide for such interaction using an approach I call \newterm{interface unwrapping}. For
example, suppose a component contains the following uses-provides list.

\singlespace
\vspace{1.0ex}
\begin{Verbatim}[fontsize=\small]
  uses interface U;
  provides interface P;
\end{Verbatim}
\vspace{1.0ex}
\primaryspacing

Although not strictly legal in Mininess I nevertheless allow specification elements indicating
interfaces in Mininess programs. These interfaces are unwrapped according to the following
rules:
\begin{enumerate}
\item When an interface is used, its commands become bare commands that are used by the
  component. Its events become bare commands that are provided by the component.
\item When an interface is provided, its commands become bare commands that are provided by the
  component. Its events become bare commands that are used by the component.
\end{enumerate}

In all cases Mininess only deals with commands. For example, suppose \inlinecode{U} and
\inlinecode{P} above are defined as shown in \autoref{figure-example-interfaces}. These
interfaces are unwrapped as also shown in the figure.

\singlespace
\begin{fpfig}[tbhp]{Example Interfaces with Unwrappings}{figure-example-interfaces}
{
\begin{Verbatim}[commandchars=+\[\], fontsize=\small]
interface U {
  command void Uc(int);
  event   void Ue(int);
}

interface P {
  command void Pc(int);
  event   void Pe(int);
}

+textit[Unwraps to+ldots]

// Unwrapped from "uses interface U"
uses     command void Uc(int);
provides command void Ue(int);

// Unwrapped from "provides interface P"
provides command void Pc(int);
uses     command void Pe(int);
\end{Verbatim}
}
\end{fpfig}
\primaryspacing

Notice that when using lower level libraries, such as TinyOS, interfaces would only be used.
However, I wish to allow for the possibility of using Scalaness to create libraries that would
be combined with pre-existing high level code. In that case Mininess components may wish to
provide a previously defined interface to that code.

It is also necessary to give the Scalaness programmer a way of specifying which library
components will back the used (or provided) interfaces. The precise components to be
incorporated into the final program are dynamically selected during the execution of the first
stage program. Thus they are declared in the Scalaness code in a manner similar to the way
Mininess components are declared, as described in \autoref{section-nesc-components}. For example
an external library component named \inlinecode{LibraryC} could be declared in Scalaness as:

\singlespace
\vspace{1.0ex}
\begin{Verbatim}[fontsize=\small]
  object LibraryC extends NesCComponent {
    external("LibraryC.nc")
  }
\end{Verbatim}
\vspace{1.0ex}
\primaryspacing

Generic external components are represented by parameterized Scalaness classes as previously
described.

\section{Safe Casts}
\label{sec:safe-casts-design}

Since one of the goals of Mininess is to promote type safety, no implicit converstion operations
are provided. Assignment and initialization from a subtype to a supertype is permitted and
explicit casts are permitted only when configured by the programmer. This allows the programmer
to disallow casts that are unsafe or illogical while also supporting casts that are logical even
if they require non-trivial user defined code to execute.

The Scalaness compiler accepts a configuration file that defines a relation on types
\textit{isCompatible}. If \textit{isCompatible($T_1$, $T_2$)} is true then it is permitted to
cast an expression of type $T_1$ into an expression of type $T_2$. There are no restrictions on
the types $T_1$ and $T_2$.

By giving the developer explicit control over casts, convention type conversions are permitted
without compromising the logical consistency of the program. Furthermore all such conversions
require explicit cast expressions; they are never applied implicitly.

The implementation of each allowed cast operation is made manifest by a command written by the
developer. This is described more in Section~\ref{sec:safe-casts-implementation}.


%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
