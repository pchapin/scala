
\chapter{Mininess Design}
\label{chapter-mininess-design}

\lstset{language=nesC}

The second stage language used by the system described here is a reduced dialect of nesC that I
call Mininess. Unlike full nesC, Mininess is restricted in a way that allows one to make a
stronger statement of the language's type and memory safety. \note{Be specific} In this respect
Mininess closely follows \newterm{nesT}, a theoretical language described in \cite{XXX}.
However, Mininess is not exactly the same as nesT in certain respects. \note{Be specific}

In this chapter I will describe the design of Mininess with a focus on how it differs from nesC
and from nesT. Roughly Mininess is a practical implementation of nesT that can be compiled with
an ordinary nesC compiler.

The description that follows assumes the reader is familiar with nesC.

% TODO: I need to describe the Mininess subset somewhat exhaustively and carefully.

\section{Component Specifications}
\label{section-component-specifications-design}

In Mininess components (after specialization) present interfaces that are sequences of imports
and exports. The imports are implemented as nesC commands that are ``used'' by the component and
the exports are implemented as nesC commands that are ``provided'' by the component. NesC-style
events are not part of Mininess but can be simulated using commands.

% TODO: The citation below should really be to the nesC specification.

Mininess does not provide separate interfaces as nesC does. Instead all interaction with other
components is done by way of separately declared commands. These bare commands can be wired
together in the usual way by the nesC compiler \cite{Gay-nesC-2003}. This approach follows nesT
as described in in \cite{FramedML,nesT}. \autoref{figure-example-mininess} shows a simple
example of a Mininess module that interacts with a timer. Instead of using an interface with an
event, the module provides a callback command.

\singlespace
\begin{fpfig}[tbhp]{Example Mininess Module}{figure-example-mininess}
{
\begin{lstlisting}[language=nesC]
module ExampleC {
    uses command void setPeriodic(uint32_t period);
    provides command void fired();
}
implementation {
    // Written in the Mininess subset.
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

A Mininess code base consists of a collection of nesC modules. These modules do not by
themselves constitute a complete program. It is the job of the first stage Scalaness program to
compose Mininess modules, along with supporting components written in full nesC, into full
applications.

Mininess currently does not support nesC-like configuration components, although such support
could be added without significantly changing the system. The Scalaness program that composes
and specializes Mininess modules is responsible for generating the application's top level (and
only) configuration. That configuration defines how the modules are wired together. \note{Say
  something about what happens when Scalaness is used on only a portion of the application}

The only units of Mininess code that Scalaness programs are allowed to manipulate are entire
Mininess modules. The component oriented nature of nesC makes this level of granularity both
sufficient and appropriate. There is no need for the first stage program to manipulate, for
example, individual Mininess functions or Mininess expressions. Also module level granularity is
easier for both the implementation of Scalaness and it's theoretical development. \note{Why?}

Each Mininess module has a nesT module type implied by its specification element list. The
handling of this module type is described in more detail in Section~\ref{XXX}.

\subsection{External Libraries}
\label{section-external-libraries-design}

My experiments with Mininess show that it is expressive enough to write useful program
components. However, any realistic application will need to interact with various libraries
written in full nesC that I call \newterm{external libraries}. It is not my intention to require
the whole program be written in Mininess and generated by Scalaness. These libraries could
represent lower level code such as the TinyOS operating system or represent higher level
application code that wishes to use Scalaness generated Mininess modules.

Neither Mininess nor Scalaness provide any direct support for interfacing to external libraries.
However, a programming technique can be used whereby shim components are manually created that
wrap library interfaces.

As an example, consider the TinyOS \lstinline!Boot! interface. This interface is used to
indicate when a node is started; all useful nesC programs must interact with it. Yet Mininess
does not support interfaces at all much less some of the entities, such as events, that are
commonly declared in nesC interfaces. Instead the programmer creates a shim component such as
\lstinline!BootShimC! as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=nesC]
module BootShimC {
    uses command void booted( );
    uses interface Boot;
}
implementation {
    event void Boot.booted( )
    {
        call booted( );
    }
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The shim component is legal nesC but not legal Mininess. Its purpose is to expose all the
commands and events in an external library interface as bare commands. To this end wrapper
command and event implementations must be manually created.

Although creating shim components is a burden their form is highly stylized. Conceivably a tool
could be created that generates them automatically. A future version of the Scalaness compiler
may perform this function. However, some shim components are complex and must do additional
transformations on command arguments to interface with the non-Mininess external library
commands. In any case, shim components can be reused across Mininess applications. I expect
programmers to accumulate a library of such shims.

The shim components must be wired to the external library components they wrap. This is done by
producing two standard nesC configurations. The first, conventionally called
\lstinline!LibraryIC! encapsulates all full nesC components that have imports. The second,
conventionally called \lstinline!LibraryEC! encapsulates all full nesC components that have
exports. Normally these are the only two configurations an application needs. If the programmer
has full control over the entire application he or she can add the necessary external library
components (via their shims) to either \lstinline!LibraryIC! or \lstinline!LibraryEC! as
appropriate.

For example, \autoref{figure-libraryic} shows an example \lstinline!LibraryIC! component for a
hypothetical application that uses the external \lstinline!MainC! component and a specific
instance of the generic timer module, both from the TinyOS library. \note{Probably need to say
  something more about how generic modules are handled}

\singlespace
\begin{fpfig}[tbhp]{Example LibraryIC configuration}{figure-libraryic}
{
\begin{lstlisting}[language=nesC]
configuration LibraryIC {
    uses command void booted( );
    uses command void fired( );
}
implementation {
    components MainC, BootShimC, SpecificTimerC;

    BootShimC.booted = booted;
    BootShimC.Boot   -> MainC;

    SpecificTimerC.fired = fired;
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

Mininess does not (currently) support nesC configurations but Scalaness does allow the component
such as the one shown in \autoref{figure-libraryic} to be declared and manipulated in Scalaness
code. Such components are represented as Scala objects that extend the
\lstinline!MininessComponent! trait as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=scalaness]
object LibraryIC extends MininessComponent {
  external("LibraryIC.nc")
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The module type of this component can't be determined by examining its nesC definition since it
is not necessarily in the Mininess subset of nesC. Instead the module type on such external
components must be annotated by the programmer as described in XXX, and is accepted without
question by the Scalaness compiler.

In a typical program there are two such objects created, one representing the
\lstinline!LibraryIC! configuration and one representing the \lstinline!LibraryEC!
configuration. These objects are then manipulated in the usual way by the Scalaness program.

Although it is not possible to use Scalaness to compose external library components directly,
the programmer is free to create several different wrapping configurations if desired and
represent each of them separately in the Scalaness program. The Scalaness program could then
dynamically select which wrapping configuration is to be used in the final generated code. In
any case the type system will ensure that illegal wirings can never be made.

\section{Safe Casts}
\label{section-safe-casts-design}

Since one of the goals of Mininess is to promote type safety, no implicit converstion operations
are provided. Assignment and initialization from a subtype to a supertype is permitted and
explicit casts are permitted only when configured by the programmer. This allows the programmer
to disallow casts that are unsafe or illogical while also supporting casts that are logical even
if they require non-trivial user defined code to execute.

The Scalaness compiler accepts a configuration file that defines a relation on types
\textit{isCompatible}. If \textit{isCompatible($T_1$, $T_2$)} is true then it is permitted to
cast an expression of type $T_1$ into an expression of type $T_2$. There are no restrictions on
the types $T_1$ and $T_2$.

By giving the developer explicit control over casts, conventional type conversions are permitted
without compromising the logical consistency of the program. Furthermore all such conversions
require explicit cast expressions; they are never applied implicitly.

The implementation of each allowed cast operation is made manifest by a command written by the
developer. This is described more in \autoref{section-safe-casts-implementation}.


%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
