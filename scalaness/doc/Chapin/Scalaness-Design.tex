\chapter{Scalaness Design}
\label{chap:scalaness-design}

\section{Liftable Types}

Certain types that appear in a Scalaness program correspond to types in the Mininess components
manipulated by that program. These types are said to be \textit{liftable}. Values of these types
can be computed in the Scalaness program and then used to specialize Mininess components. These
values need to be transformed as they cross the boundary between the two programming languages
in response to differences in the way a liftable type and its Mininess counterpart are
represented. In this section I will describe which Scalaness types are liftable and how their
values are handled when used to specialize a Mininess component.

\subsection{Primitive Types}

All liftable types are subtypes of a special marker trait \texttt{NesCType}. The primitive types
in Mininess have liftable counterparts in Scalaness that are classes extending
\texttt{NesCType}. These classes and their corresponding Mininess types are shown in
Table~\ref{tbl:primitive-liftable}.

\begin{table}
  \centering
  \caption{Primitive Liftable Types}
  \label{tbl:primitive-liftable}
  \begin{tabular}{|l|l|} \hline
    \textit{Scalaness Type} & \textit{Mininess Type} \\ \hline
    Uninit & void      \\ \hline
    Char   & char      \\ \hline
    UInt32 & uint32\_t \\ \hline
    UInt16 & uint16\_t \\ \hline
    UInt8  & uint8\_t  \\ \hline
    Int32  & int32\_t  \\ \hline
    Int16  & int16\_t  \\ \hline
    Int8   & int8\_t   \\ \hline
  \end{tabular}
\end{table}

The Mininess subtype relations are preserved in Scalaness where \texttt{UInt8} <:
\texttt{UInt16} <: \texttt{UInt32} and similarly for the signed integer types. In Scalaness
these types are defined in the object \texttt{LiftableTypes} so that they don't conflict with
any normal (non-liftable) types defined by the programmer or the language, such as
\texttt{Char}. Furthermore the integer liftable types are endowed with the usual arithmetic
operations so they can be manipulated in the Scalaness program in a natural way.

No conversions are provided between the liftable types and their ordinary Scala analogs. This
means existing libraries that, for example, manipulate Scala \texttt{Char} objects won't work
with \texttt{LiftableTypes.Char}. I do not consider this a problem for two reasons.
\begin{enumerate}
\item Since values of liftable type will eventually be written into Mininess modules, they will
  likely be put to very different uses than values of ordinary Scala type.
\item Conversions (including implicit conversions) can be easily added by the Scalaness
  programmer if desired.
\end{enumerate}

To facilitate the second point, explicit conversion methods from each liftable type to its
obvious non-liftable counterpart are provided.

% TODO: The following two paragraphs should be moved to the Scalaness-Implementation section.

The Scala type system is used to ensure compile-time type safety of the primitive liftable types
in a Scalaness program. For example the type \texttt{Int16} can only be constructed using a
value of Scala's type \texttt{Short}. Consequently normal Scala type checking prevents a
potentially out of range value from being used.

Unfortunately Scala does not support unsigned types natively. In the current implementation a
sufficiently wide signed type is used to initialize objects of unsigned liftable type. This
makes it possible to use an out-of-range value during the execution of the Scalaness program
resulting in a runtime exception. I don't believe this can be avoided without adding support for
unsigned types to the Scala compiler.

\subsection{Arrays}

\subsection{Structures}

A Scala class $C$ that extend the \texttt{NesCType} trait is liftable to a Mininess structure
type provided it additionally obeys the following inductive rules.

\begin{enumerate}
\item $C$ is not generic.
\item All of $C$'s fields have liftable type.
\item All of $C$'s supertypes (except \texttt{AnyRef} and \texttt{ScalaObject}) are liftable
  types.
\end{enumerate}

In this case $C$ is said to be a \textit{liftable class}. Except for the rules mentioned here
there are no restrictions on the definition or use of liftable classes. In particular, they are
able to have convenience methods, although the methods of a liftable class have no manifestation
in the generated Mininess code.

For example, consider the following Scalaness code:

\singlespace
\begin{lstlisting}[language=scalaness]
class Header
 (val nodeID      : nodeIDType,
  val componentID : UInt8 ) extends NesCType

class TimeStampedHeader
 (val timeStamp   : UInt16) extends Header
\end{lstlisting}
\primaryspacing

Here \texttt{nodeIDType} is a previously defined liftable class type. Consequently both of these
classes are liftable and have representations as Mininess structure types. \note{TODO: Figure
  out how to properly model Scala's inheritance system in this context.}

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
