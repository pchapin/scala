\chapter{Introduction}
\label{chapter-introduction}

Embedded systems present difficult programming challenges
\cite{Mottola:2011:PWS:1922649.1922656}. For reasons of size, power consumption, disposability,
or some combination of these things, embedded devices are often highly resource constrained. For
example, a typical device might have only 48~KiB of program ROM, 8~KiB of RAM, and use a small,
16~bit microcontroller running at 8~MHz \cite{tmotesky-datasheet}. Yet embedded applications are
increasing in complexity and often provide mission-critical or even safety-critical services.
Such systems need to be both efficient and correct.

My interest is in the use of distributed trust management in resource constrained embedded
systems. Here \newterm{trust management} refers to a general approach for authorizing access to
resources in an environment where the identity of requesting principals is not known to the
authorizer. A trust management system provides a way for the authorizer to define an access
policy in terms of arbitrary certified attributes that the requester must possess. Many trust
management systems have been described in the literature \cite{chapin-skalka-wang-acmcs08}, and
they vary in complexity, expressivity, and mathematical foundations. However, all attempt to
provide a well structured approach to the problem of access control in widely distributed and
dynamic environments.

Trust management systems are typically designed for use by authorizers with resource rich
machines such as is commonly used for file and web servers. Yet there are embedded applications
that could also benefit from trust management. For example, ``smart cars'' that communicate with
each other about road conditions \cite{Seepold:2009:ESP:1641563.1641568}, or body area networks
that provide medical monitoring features
\cite{Shnayder:2005:SNM:1098918.1098979,Chen:2011:BAN:1968858.1968873} may encounter many
unknown principals during their operation. The security and safety of these applications will
depend on their ability to distinguish trustworthy principals from unreliable or malicious ones.

For reasons of space and time efficiency many embedded systems are programmed in low level
languages such as C. Programming at that level is complicated and error prone. It is desirable,
therefor, to provide programmers with convenient abstractions to shield them from low level
complexities. I believe, in particular, that these abstractions should be in the programming
language itself, and my work is about providing enriched languages that can be used to address
the needs of modern embedded systems. This \newterm{language-based} approach off-loads some of
the work of producing correct programs to the language compiler and runtime system. Language
features can be formally analyzed and rigorously tested once and then applied to many
applications. This is in contrast to each application being an ad-hoc construction of customized
components with limited use beyond the application for which they were created.

The value of formal foundations can not be overstated. In critical systems were safety or
security is at stake, a rigorous understanding of the mechanisms being used is essential. For
example, trust management systems that provide a precisely defined policy language are
preferable to systems that use informally described methods.

In this dissertation I focus on a kind of embedded system called a \newterm{wireless sensor
  network} (WSN). Such systems consist of a network of small sensors or actuators that are
connected by way of short hop wireless links. Commonly such networks include one or more base
stations, or ``hubs,'' with wider connectivity that serve as an interface between the sensor
network and external systems. Wireless sensor networks are an area of intense study with many
envisioned applications ranging from environment, asset, and structural monitoring to emergency
response \cite{Culler:2004:GEI:1018015.1018072,1038146}. Yet despite my use of sensor networks
to demonstrate the systems I describe, the techniques can be used with a wide range of embedded
applications.

I describe two approaches to solving the problem of providing trust management-style distributed
authorization in resource constrained embedded systems. The first approach is based on a new
remote procedure call (RPC) discipline called \textit{SpartanRPC}
\cite{chapin-skalka-SpartanRPC,chapin-skalka-SpartanRPCTR}. In this method all authorization
computations are done directly on the embedded devices. However, the complexity of the system is
hidden from the programmer behind a simple extension to the widely used nesC programming
language \cite{Gay-nesC-2003}. My implementation of this \emph{direct} approach is a compiler
called \textit{Sprocket} that takes an extended dialect of the nesC language as input and
outputs an equivalent program in ordinary nesC. In addition Sprocket outputs the necessary
runtime support to process authorization requests and policy statements in the $RT_0$ trust
management language \cite{Li:DRBTMF,Li:RRBTMF}.

The second approach I present is based on \newterm{staged programming}
\cite{Taha-MetaML,Sheard-TemplateHaskell,Mainland-Flask-2008,FramedML}. In a staged environment,
a first stage program is used to compose and specialize a lower level, second stage program.
Specialized code can often be considerably optimized. However, flexibility is retained because
the first stage program can be re-executed at a later time to re-specialize the second stage
program as needed.

Unlike many staging systems I am interested in the application of staging where the stages use
different programming languages and execute on different machines, i.e., in different address
spaces. When applied to embedded systems, the second and final stage must be in an embedded
systems language running on the embedded hardware, whereas the first stage need not be as
restricted.

In this dissertation I also describe \newterm{Scalaness} \cite{chapin-GPCE-2013}, an extension
of Scala \cite{PiS2} with features that allow the programmer to compose and specialize
components written in a reduced dialect of nesC called \newterm{nesT}. An important novel
feature of Scalaness is that it extends Scala's type system so that a well-typed Scalaness
program will always generate a well-typed nesT program. Thus the type correctness of the program
that ultimately runs on the embedded device is guaranteed by the first stage Scalaness compiler.

I chose Scala as the basis for my first stage language largely for pragmatic reasons. I wanted
to build a system that could be used for real applications. Scala is a rich language that runs
on the Java Virtual Machine (JVM) and thus has access to the Java ecosystem. Also the Scala
compiler has a plugin architecture, and I had hoped to implement Scalaness as a compiler plugin.
Unfortunately, as described in \autoref{chapter-scalaness-nest} that proved difficult and
Scalaness was instead implemented as a direct modification to the Scala compiler itself.

\section{Motivation}

To better understand the motivation behind my work in this section I will describe an example
scenario related to wireless sensor networks. I describe the scenario in general terms; it could
apply to a variety of sensor network applications, one of which I discuss in more detail in
\autoref{chapter-evaluation}.

\begin{fpfig*}[t]
  {Motivational Scenario}
  {figure-motivation}
  %\hspace{0mm}
  \begin{center}
    \includegraphics[scale=.40]{Figures/spartanrpc.eps}
  \end{center}
\end{fpfig*}

The lower part of \autoref{figure-motivation} shows two wireless sensor networks owned by
separate administrative domains $A$ and $B$. Each node in the network is an example of a
resource constrained embedded system. The two networks overlap in space so that nodes from the
two networks can potentially communicate with each other.

In some applications it may be desirable for the networks to share certain information while
keeping other information private. As one example $A$ and $B$ may agree to use each other's
nodes for accurate time synchronization to their mutual best interest without wanting to share
any other functionality. Alternatively perhaps the networks are willing to carry data from
foreign isolated nodes thus increasing each other's connectivity and enhancing their useful
lifetimes, all without being able to access each other's primary functions.

In other scenarios one of the networks, say $B$, may be reduced to a single mobile node that
wanders into the field of an established network $A$. In that case $B$ may wish to query $A$ or
otherwise interact with it, yet $A$ and $B$ may have no prior association.

Trust management systems provide exactly the kind of flexible, policy-driven authorization
control to address these situations. The ability to define access policy for unknown principals,
the hallmark of trust management, is particularly important in the case of mobile embedded
systems.

SpartanRPC addresses this problem directly by providing a way for the embedded devices
themselves to execute trust management logic. In that case no additional supporting
infrastructure is needed but the nodes are required to do extensive computations.

Scalaness, as a staged programming system, requires support beyond the nodes where the first
stage program can execute. This additional support is shown on top of
\autoref{figure-motivation} where Scalaness programs execute on the base stations of $A$ and $B$
to compute node programs for deployment that are specialized with appropriate session keys. The
Scalaness programs can communicate over the Internet to share credentials or other security
tokens as required.

\section{Related Work}

% From the Trust Management paper.

The first trust management systems were inspired by early foundational work in authentication
logics such as BAN \cite{Burrows:LA} and authorization logics such as ABLP \cite{Abadi:CACDS}.
However, the concept of trust management as an independent area of study was first introduced
with PolicyMaker \cite{Blaze:DTM,Blaze:CCPTMS}. PolicyMaker policies are implemented as
arbitrary programs in a suitable ``safe'' programming language. This gives the system great
flexibility but also introduces intractability.

KeyNote \cite{RFC-2704} is a direct descendant of PolicyMaker. KeyNote restricts PolicyMaker by
specifying a limited language for creating policies. However a full analysis of KeyNote's policy
language \cite{Li:DCFTML} shows that certain authorization problems nevertheless remain
undecidable. KeyNote has been used to enforce IPsec security requirements
\cite{Blaze:TMIPS,Blaze:EKTMS}

SDSI/SPKI \cite{Rivest:SDSI-11,RFC-2693} provides a relatively simple, yet expressively
interesting trust management language that is a precursor to the $RT_0$ system I used. The
semantics of SDSI/SPKI have been analyzed by several authors
\cite{Abadi:OSLLNS,Halpern:LSSLLNS,Howell:FSS,Li:LNSS,Clarke:CCDSS} making it one of the best
studied trust management systems. SDSI/SPKI has been used to provide security in component based
programming language design \cite{Liu:CSI}.

QCM \cite{Gunter:DALSI,Gunter:GCR} and its successor SD3 \cite{Jim:STMSCE,Jim:DDQE} cast
distributed authorization as a kind of distributed database problem. As a result these systems
are able to leverage well-studied database techniques and abstractions. These systems reveal a
deep and interesting connection between authorization logics and database theory that inspired
later work with database query languages such as \datalog\ and \datalogc\ \cite{Li:DCFTML}.

Other notable examples of trust management systems include Cassandra \cite{Becker:CFTMAEHR}, a
system that has been studied in the context of the United Kingdom's proposed nationwide
electronic health records system. The Extensible Access Control Markup Language (XACML)
\cite{OASIS:XACMLTC} and the Security Assertion Markup Language (SAML) \cite{OASIS:SSTC}, both
OASIS standards, define XML policy and assertion languages that make use of many trust
management concepts.

% From the TISSEC paper.

Extending sensor network software platforms with support for secure interactions between domains
has been studied in previous research on SSL for sensor networks \cite{10.1109/WAINA.2009.47}.
However, this work was focused on extending the Internet to sensor networks (aka ``IP for
WSNs''), whereas SpartanRPC is a more general system for enhancing secure communications
\emph{within} a sensor network. Research on sensor network security has also addressed secure
routing \cite{senroute-ahnj03}, link layer security \cite{karlog-tinysec-2004}, cryptography
\cite{bertoni-2006}, key distribution \cite{camtepe-bulent-05}, and hardware issues
\cite{perrig-2004}. In contrast to these low-level systems, SpartanRPC provides language-level
abstractions for secure RPC services. Perhaps even more closely related is a system for
establishing fine-grained, ``node-level'' policies in sensor networks
\cite{Claycomb:2011:NNL:1889383.1889450}. However, this work is more focused on group-based key
negotiation and distribution, and while it does offer a policy language, it is rooted in
implementation details and not as a separable specification. Also, that work does not provide a
language API for integrating their system into secure applications as does SpartanRPC.

Previous related work also illustrates interest in and useful applications of RPC in embedded
networks. For example, the Marionette system uses network layer RPC for remote (PC-based)
analysis and debugging of sensor networks \cite{whitehouse-marionette-2006}. The Fleck operating
system provides a small pre-defined set of RPC services for sensor network applications, while
the trustedFleck system extends this with a form a secure RPC
\cite{hu-secfleck-2009,Hu:2010:TTW:1806895.1806900}. S-RPC provides an RPC facility for sensor
networks that allows remote services to be added to the system dynamically \cite{5766863}.
SpartanRPC differs from these systems in that it extends the nesC programming language (unlike
trustedFleck) to allow programmer definition of secure RPC services (unlike S-RPC) that can be
accessed by nodes within the network itself (unlike Marionette). Our system is similar to and
inspired by TinyRPC \cite{may-tinyrpc-2007}, except the latter does not provide security and has
a different semantics that are not as expressive as our approach.

Teeny\textsc{lime} allows application programs to access an abstract ``tuple space'' that is the
union of tuple spaces on the local node and the immediately neighboring nodes
\cite{Costa:2007:PWS:1516124.1516153}. This provides an alternative to RPC for uniformly
accessing remote and local data. However, interaction with the middleware is by way of a
dedicated API; there is no attempt to provide a true RPC mechanism. Also Teeny\textsc{lime} does
not address issues of access control.

Secure Middleware for Embedded Peer to Peer systems (SMEPP) is a general framework for creating
security sensitive applications from a distributed network of embedded peers
\cite{Brogi:2008:SME:1363370.1363548}. SMEPP Light \cite{Vairo:2008:SMW:1594978.1595054} is a
reduced version of SMEPP to address the resource constraints of wireless sensor networks. SMEPP
Light provides a publish/subscribe communication model using directed diffusion
\cite{intanagonwiwat-2003} to distribute ``events'' to all subscribers and symmetric key
cryptography to provide confidentiality and data integrity within a group of nodes. However,
SMEPP Light is not integrated into a programming language and does not provide a remote
procedure call mechanism. Furthermore SMEPP Light only supports a simple model of access control
based on group membership.

High level macro\-programming languages such as Kairos \cite{springerlink:10.1007/1150259312},
and Regiment \cite{Newton:2007:RMS:1236360.1236422} provide a way to program the entire network
as a single entity. These systems attempt to hide not only the inter-node communication from the
programmer, but also the entire node level programs. SpartanRPC operates at a much lower level
and also, unlike these macro\-programming systems, addresses access control issues in networks
containing multiple security domains.

Whole network programming of wireless sensor networks has also been investigated using mobile
agents in systems such as Agilla \cite{Fok:2009:AMA:1552297.1552299} and Wiseman
\cite{Gonzalez-Valenzuela:2010:PMW:1891545.1891566}. However, like the macro\-programming
systems mentioned previously neither of these systems address issues related to access control
in the presence of multiple security domains.

% From the GPCE paper

The work described here follows the foundational \fml\ work \cite{FramedML};
\autoref{section-framedml} discusses how it serves as the theoretical underpinning of Scalaness.

The potential of applying metaprogramming to sensor networks was explored in the functional
sensor language Flask \cite{Mainland-Flask-2008}. Flask allows functional reactive programming
(FRP)-based stream combinators to be pre-computed before network deployment, but it is possible
to generate ill-typed Flask object code since cross-stage static type checking is not performed.
Hume \cite{Hume} is a domain specific language for real-time embedded device programming. It
includes a metaprogramming layer but that layer is more like nesC's configuration files in that
there is a very restricted syntax for a few special metaprogramming operations including
component wiring, macros, and code templating.

MetaML \cite{Taha-MetaML,DBLP:conf/icess/Taha04} and MetaHaskell \cite{mainland12} are
foundations my work builds on. MetaHaskell does support heterogeneous language staging where the
lower stage language is defined by a plug-in and several instantiations have been defined
including one for a low-level C-like language. Like our approach they guarantee type safety of
all lower-stage code produced. They use a more traditional metaprogramming model, however, not
the process-separated model needed for embedded systems metaprogramming and do not address the
issues of metaprogramming module composition and type specialization.

Lightweight Modular Staging \cite{Rompf-LMS} describes a method of expressing staged
computations using a Scala host framework without any compiler modifications. The approach
allows cross-stage type safety but also does not support dynamic type construction.

Actor based sensor metaprogramming has been studied in \cite{cheong07}; this work shares my
focus on high level dynamic reprogrammability but is untyped. More broadly, meta programming is
known to be useful for increasing the efficiency of systems applications. One example is Tempo
\cite{289140}, a system that integrates partial evaluation and type specialization for
increasing efficiency of systems applications. Ur \cite{UrPLDI10} allows for type safe meta
programming for web applications.

The units of staged code composition in nesT programming are \emph{modules}. Countless different
module systems exist, but they are primarily designed to achieve separate compilation and sound
linking \cite{Cardelli-1997}. My different design goal leads to different design choices in nesT
modules. For example, data crossing nesT module boundaries needs to conform to the property of
process separation, a non-issue in standard module system designs. In addition, nesT modules
allow values/types across the boundary of modules to be flexibly constructed, including dynamic
construction of types. Module systems such as ML modules \cite{macqueen84} and Units
\cite{flatt98units} allow types to be imported/exported as I also support. However, there are
several features of ML modules including type hiding that my system does not aim to support.

NesT modules are more expressive in their support of first class modules as values and the
possibility of dynamic construction of ``type exports.'' That said, first class modules are not
new \cite{99620,ancona01calculus}, The novelty of nesT arises in its application to program
staging and the incorporation of dynamic type construction.

The type parametricity of System F and F$_\le$ \cite{Cardelli-1985}, and the practical type
systems it inspired such as Java's generics, do not treat types as first class values. C++
templates support types as meta values in template expansion, but type safety of generated code
is not guaranteed without full template expansion. Concepts \cite{gregor06:_concepts} improves
on this, but types are still not first class values.

\section{Dissertation Organization}

The rest of this dissertation is organized as follows. I describe trust management systems in
general in \autoref{chapter-trust-management}, outlining the different features provided by
common trust management systems and motivating their use. I also give special focus on the \RT\
family of trust management systems used in my work. I describe the design of SpartanRPC and the
details of its implementation in \autoref{chapter-spartanrpc-sprocket}. In particular, I
describe how I added support for $RT_0$ trust management to a general RPC mechanism. I introduce
Scalaness and nesT in more detail in \autoref{chapter-dscalaness-dnest}, and then describe the
syntax and semantics of both languages using simplified ``distilled'' versions of those
languages called \newterm{DScalaness} and \newterm{DnesT}. I describe the implementation of the
practical Scalaness/nesT system in \autoref{chapter-scalaness-nest} relating the features of the
implementation to the earlier foundational presentation. I show an evaluation of both systems in
\autoref{chapter-evaluation} using simple test programs and in the context of a realistic field
example. Finally I conclude in \autoref{chapter-conclusion}.


%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
