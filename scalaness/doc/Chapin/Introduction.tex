\chapter{Introduction}
\label{chapter-introduction}

A \newterm{wireless sensor network} (WSN) is a network composed of small sensors or actuators
that are connected by way of short hop wireless links. Often, but not always, such networks
include one or more base stations with wider connectivity that serve as an interface between the
sensor network and external systems. WSNs are an area of intense study with many envisioned
applications ranging from X to Y \cite{XXX}.

Sensor networks, like any small embedded system, present difficult programming challenges. For
reasons of size, power consumption, disposability, or some combination of these things, sensor
network nodes are often highly resource constrained. A typical node might have only 48~KiB of
program ROM, 8~KiB of RAM (or less), and be using a small, 16~bit microcontroller running at
only 8~MHz \cite{tmotesky-datasheet}. Yet WSN applications are increasing in complexity. In
addition to application logic, such systems are now expected to support various network protocol
stacks \cite{XXX}, elaborate security services \cite{XXX}, and etc \cite{XXX}.

My interest is in discovering how to effectively program these limited devices to meet high
level security goals. While there has been a great deal of research on security in sensor
networks much of that work has focused on low level concerns such as link layer security
\cite{XXX}, key distribution \cite{XXX}, and secure network protocols \cite{1049776,XXX}. My
concern is rather to support high level authorization policies that allow a network in one
security domain to grant selective access to its resources by nodes in a cooperating security
domain. Such distributed authorization systems, called \newterm{trust management systems} have
also been an active area of research \cite{XXX}.

A trust management system typically entails the use of public key cryptography and a system for
evaluating authorization requests in the light of some access policy. Although the feasibility
of using public key cryptography on sensor nodes has been shown by several authors
\cite{bertoni-2006,Liu-Peng-TinyECC-2008,Szczechowiak:2008:NTL:1786014.1786040}, combining this
with the necessary authorization computations to support a full trust management system, and
showing the feasibility and practicality of doing so, has not been previously demonstrated.

Here I show two approaches to solving the problem of providing trust management-style
distributed authorization in WSNs. The first approach is based on an RPC discipline called
\textit{SpartanRPC}. In this method all cryptographic and authorization computations are done on
the sensor nodes directly. However, the complexity of the system is hidden from the programmer
behind an easy to use extension of the widely used nesC programming language
\cite{Gay-nesC-2003}. My implementation of this direct approach is a compiler called
\textit{Sprocket} that takes the extended nesC language as input and outputs an equivalent
program in regular nesC. In addition Sprocket outputs the necessary runtime support to process
authorization requests and policy statements in the $RT_0$ trust management language
\cite{Li:DRBTMF,Li:RRBTMF}.

The second approach I present is based on \newterm{staged programming}. In a staged environment,
a first stage program is used to compose and specialize a lower level, second stage program.
Specialized code can often be considerably optimized. However, flexibility is retained because
the first stage program can be re-executed at a later time to re-specialize the second stage
code as needed.

Staging is a widely researched topic
\cite{Taha-MetaML,Sheard-TemplateHaskell,Mainland-Flask-2008,FramedML}. \note{Probably should
  only mention the seminal papers here.} Many of these systems are quite general and allow an
arbitrary number of stages where each stage can manipulate small fragments of next-stage code.
Furthermore most existing systems \note{except\ldots} use the same language in all stages.
Finally the type correctness of the stage $n+1$ programs are normally checked during their
compilation or during the execution of the stage $n$ programs that produce them.

I focus here on the specific problem of using staged programming to improve the general
efficiency of node level programs for wireless sensor networks. In such an environment the first
stage program is envisioned to run on a powerful base station or even a hand-held device such as
a smart phone. Using information gathered in the field, the first stage program computes an
appropriately specialized second stage program that is then deployed to the network using an
in-situ distributed deployment system such as Deluge \cite{XXX}. Feedback provided by the
network allows the first stage program to recompute an updated second stage program that can
then be redeployed. The second stage program running on the sensor nodes remains small and
efficient and yet long term flexibility is retained.

In this environment only two stages are necessary so a language that provides an arbitrary
number of stages is not required. Furthermore the practical realities of sensor network
programming means that the second stage language needs to be either C or nesC or some dialect of
these languages. However, nesC, especially, is an embedded systems language and not suitable for
creating high level applications. Thus the first stage language can and should be something
different.

In this dissertation I describe \newterm{Scalaness}, an extension of Scala \cite{PiS2} with
features that allow the programmer to compose and specialize components written in a reduced
dialect of nesC called \newterm{Mininess}. One novel feature of Scalaness is that the type
system of Scala has been modified so that a well-typed Scalaness program will always generate a
well-typed Mininess program. No type errors will arise in the field when a compiled Scalaness
program is used to repeatedly generate specialized node programs. This is essential since the
user of the Scalaness program won't be a position to deal with type errors in the Mininess
generated by that program.

Scalaness is a general system that can be applied to many sensor network applications or even
potentially other kinds of embedded systems. To demonstrate the effectiveness of the system I
use Scalaness to provide the same trust management support as demonstrated with Sprocket. I then
compare the effectiveness of the two systems.

The rest of this dissertation is organized as follows. In Chapter~2 I describe trust management
systems in general and motivate their use in sensor network applications. In Chapter~3 I
describe a practical test application that I used to demonstrate the feasibility of both
Sprocket and Scalaness. In Chapter~4 I describe the design and implementation of Sprocket. In
Chapter~5 I describe the design and implementation of Scalaness. In Chapter~6 I show an
evaluation of these systems as applied to the extended example. Finally in Chapter~7 I conclude.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
