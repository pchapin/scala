\chapter{Introduction}
\label{chap:introduction}

Embedded systems in general, and wireless sensor networks in particular, often entail
programming small, resource constrained systems. A typical node in a wireless sensor network
might have only 48 KiB of program ROM and 8 KiB of RAM (or less), and be using a small, 16~bit
microcontroller running at only 8 MHz \cite{XXX}. Yet embedded systems applications are
increasing in complexity. In addition to application logic, such systems are now expected to
support various network protocol stacks, etc, etc, and elaborate security services, etc
\cite{XXX}.

One approach to writing highly efficient programs is to use \newterm{staging}. In a staged
programming environment, a first stage program is used to compose and specialize a lower level,
second stage program. The first stage program, which can run on a powerful system, takes care of
certain tasks ahead of time relieving the second stage program of the burden of making those
computations itself. Specialized code can always be more optimized. However, flexibility is
retained because the first stage program can be re-executed at a later time to account for
changes in the environment.

Staging is a widely researched topic
\cite{Taha-MetaML,Sheard-TemplateHaskell,Mainland-Flask-2008,FramedML}. \note{Probably should
  only mention the seminal papers here.} Many of these systems are quite general and allow an
arbitrary number of stages where each stage can manipulate small fragments of next-stage code.
Furthermore most existing systems (except\ldots) use the same language in all stages. Finally
the type correctness of the stage $n+1$ programs are normally checked during their compilation
or during the execution of the stage $n$ programs that produce them.

I focus here on the specific problem of using staged programming to improve the efficiency of
node level programs for wireless sensor networks. In that environment the first stage program is
envisioned to run on a powerful base station or even a hand-held device such as a smart phone.
Using information gathered in the field, the first stage program computes an appropriately
specialized second stage program that is then deployed to the network using an in-situ
distributed deployment system such as Deluge \cite{XXX}. Feedback provided by the network allows
the first stage program to recompute an updated node program that can then be redeployed. The
node level programs remain small and efficient and yet long term flexibility is retained.

In this environment only two stages are necessary so a language that provides an arbitrary
number of stages is not required. Furthermore the practical realities of sensor network
programming means that the second stage language needs to be either C or nesC
\cite{Gay-nesC-2003} or some dialect of these languages. However, nesC especially is an embedded
systems language and not suitable for creating high level applications. Thus the first stage
language can and should be something different.

In this dissertation I describe \newterm{Scalaness}, a dialect of Scala \cite{PiS2} with
extensions that allow the programmer to compose and specialize components written in a reduced
dialect of nesC called \newterm{Mininess}. One novel feature of Scalaness is that the type
system of Scala has been modified so that a well-typed Scalaness program will always generate a
well-typed Mininess program. No type errors will ever arise in the field when a compiled
Scalaness program is used to repeatedly generate optimized node programs. This is essential
since the user of the Scalaness program won't be a position to deal with type errors arising
in the nesC generated by that program.

\note{Talk about the ``deliverables'' of this work. Talk about SpartanRPC. Give organization of
  the rest of the document.}

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
