\chapter{Introduction}
\label{chapter-introduction}

A \newterm{wireless sensor network} (WSN) is a network composed of small sensors or actuators
that are connected by way of short hop wireless links. Often, but not always, such networks
include one or more base stations with wider connectivity that serve as an interface between the
sensor network and external systems. WSNs are an area of intense study with many envisioned
applications ranging from X to Y \cite{XXX}.

Sensor networks, like any small embedded system, present difficult programming challenges. For
reasons of size, power consumption, disposability, or some combination of these things, sensor
network nodes are often highly resource constrained. A typical node might have only 48~KiB of
program ROM, 8~KiB of RAM (or less), and be using a small, 16~bit microcontroller running at
only 8~MHz \cite{tmotesky-datasheet}. Yet WSN applications are increasing in complexity. In
addition to application logic, such systems are now expected to support various network protocol
stacks \cite{XXX}, elaborate security services \cite{XXX}, and etc \cite{XXX}.

My interest is in discovering how to effectively program these limited devices to meet high
level security goals. While there has been a great deal of research on security in sensor
networks much of that work has focused on low level concerns such as link layer security
\cite{XXX}, key distribution \cite{XXX}, and secure network protocols \cite{1049776,XXX}. My
concern is rather to support high level authorization policies that allow a network in one
security domain to grant selective access to its resources by nodes in a cooperating security
domain. Such distributed authorization systems, called \newterm{trust management systems} have
also been an active area of research \cite{chapin-skalka-wang-acmcs08}.

A trust management system typically entails the use of public key cryptography to allow
principals to authorize each other without prior introduction, and a system for evaluating
authorization requests in the light of some access policy. Although the feasibility of using
public key cryptography on sensor nodes has been shown by several authors
\cite{bertoni-2006,Liu-Peng-TinyECC-2008,Szczechowiak:2008:NTL:1786014.1786040}, combining this
with the necessary authorization computations to support a full trust management system, and
showing the feasibility and practicality of doing so, has not been previously demonstrated.

Here I show two approaches to solving the problem of providing trust management-style
distributed authorization in WSNs. The first approach is based on an RPC discipline called
\textit{SpartanRPC}. In this method all cryptographic and authorization computations are done on
the sensor nodes directly. However, the complexity of the system is hidden from the programmer
behind an easy to use extension of the widely used nesC programming language
\cite{Gay-nesC-2003}. My implementation of this direct approach is a compiler called
\textit{Sprocket} that takes the extended nesC language as input and outputs an equivalent
program in regular nesC. In addition Sprocket outputs the necessary runtime support to process
authorization requests and policy statements in the $RT_0$ trust management language
\cite{Li:DRBTMF,Li:RRBTMF}.

The second approach I present is based on \newterm{staged programming}. In a staged environment,
a first stage program is used to compose and specialize a lower level, second stage program.
Specialized code can often be considerably optimized. However, flexibility is retained because
the first stage program can be re-executed at a later time to re-specialize the second stage
code as needed.

Staging is a widely researched topic
\cite{Taha-MetaML,Sheard-TemplateHaskell,Mainland-Flask-2008,FramedML}. \note{Probably should
  only mention the seminal papers here.} Many of these systems are quite general and allow an
arbitrary number of stages where each stage can manipulate small fragments of next-stage code.
Furthermore most existing systems \note{except\ldots} use the same language in all stages.
Finally the type correctness of the stage $n+1$ programs are normally checked during their
compilation or during the execution of the stage $n$ programs that produce them.

I focus here on the specific problem of using staged programming to improve the general
efficiency of node level programs for wireless sensor networks. In such an environment the first
stage program is envisioned to run on a powerful base station or even a hand-held device such as
a smart phone. Using information gathered in the field, the first stage program computes an
appropriately specialized second stage program that is then deployed to the network using an
in-situ distributed deployment system such as Deluge \cite{deluge04}. Feedback provided by the
network allows the first stage program to recompute an updated second stage program that can
then be redeployed. The second stage program running on the sensor nodes remains small and
efficient and yet long term flexibility is retained.

\note{Should I include the figure here that illustrates the blocks in a Scalaness system?}

In this environment only two stages are necessary so a language that provides an arbitrary
number of stages is not required. Furthermore the practical realities of sensor network
programming means that the second stage language needs to be either C or nesC or some dialect of
these languages. However, nesC, especially, is an embedded systems language and not suitable for
creating high level applications. Thus the first stage language can and should be something
different.

In this dissertation I describe \newterm{Scalaness}, an extension of Scala \cite{PiS2} with
features that allow the programmer to compose and specialize components written in a reduced
dialect of nesC called \newterm{Mininess}. One novel feature of Scalaness is that the type
system of Scala has been modified so that a well-typed Scalaness program will always generate a
well-typed Mininess program. No type errors will arise in the field when a compiled Scalaness
program is used to repeatedly generate specialized node programs. This is essential since the
user of the Scalaness program won't be a position to deal with type errors in the Mininess
generated by that program.

Scalaness is a general system that can be applied to many sensor network applications or even
potentially other kinds of embedded systems. To demonstrate the effectiveness of the system I
use Scalaness to provide the same trust management support as demonstrated with Sprocket. I then
compare the effectiveness of the two systems.

\section{Field Example}

To illustrate the two approaches described here in a realistic setting I will use a common
example based on the SnowCloud system \cite{XXX}. This system was developed by (who?) to (do
what?). \note{FIXME} It consists of two node level applications. The first application, called
SensorBox, runs on the sensor network itself, gathers data related to snow depth, and saves it
in non-volatile storage on each node. The second application, called Harvester, runs on a
specialized device that is hand carried into the field and collects sensor data from the
network. The Harvester issues commands to the nodes as well as collects data from the nodes.

\note{Describe the SnowCloud application in more detail. Moving on for now\ldots}

\subsection{SnowStorm}

\note{Move the description of policy into the chapter on Trust Management. Move the details of
  SnowStorm to the chapter on nesT and Scalaness.}

I visualize a scenario where the administrative domain running the Harvester might be different
from the administrative domain owning the sensor network. Each of these domains is its own
$RT_0$ entity, called $H$ and $N$ respectively. $N$ defines the role \texttt{control}, the
members of which are able to send commands to network nodes. Each node holds the following
policy
\begin{Verbatim}
N.control <- H
N.control <- N
\end{Verbatim}

It is necessary for $N$ to be made a member of $N.\textrm{control}$ so that commands can be
forwarded from node to node during their dissemination. \note{Is there value in defining a more
  interesting policy?}

The Scalaness program, called SnowStorm, is able to generate both the Harvester and SensorBox
applications. \autoref{fig:running-snowstorm} shows two instances of SnowStorm running, $S_H$
and $S_N$, one by each administrative domain. $S_H$ is only interested in generating the
Harvester application and $S_N$ is only interested in generating the SensorBox application.
Conceptually the two domains might run completely independent Scalaness programs, but as a
convenience during development and testing a single program was created to serve the needs of
both domains.

\begin{figure}[htbp]
  \input{Figures/SnowStorm}
  \centerline{\raise 1em\box\graph}
  \caption{Running SnowStorm}
  \label{fig:running-snowstorm}
\end{figure}

$S_H$ and $S_N$ are assumed to both have Internet access and run continuously. $H$ requests
authorization from $N$ and, if successful, session keys are negotiated over the Internet.
SnowStorm provides a menu that allows an interactive user to control its operation and trigger
the generation of the node level programs.

Each instance of SnowStorm holds the private key of its domain and maintains a database of
public keys ($RT$ entities) and certificates ($RT$ policy). Users are able to issue new
certificates under their domain's key.


\section{Dissertation Organization}

The rest of this dissertation is organized as follows. In \autoref{chapter-trust-management} I
describe trust management systems in general and motivate their use in sensor network
applications. In \autoref{chapter-spartanrpc-sprocket} I describe the direct approach to
providing useful trust management authorization in sensor networks based on SpartanRPC and
Sprocket. In \autoref{chapter-nest-scalaness} I describe the staged approach based on nesT and
Scalaness. In \autoref{chapter-evaluation} I show an evaluation of these systems as applied to
the extended example. Finally in \autoref{chapter-conclusion} I conclude.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
