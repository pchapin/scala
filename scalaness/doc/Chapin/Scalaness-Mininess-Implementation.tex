\chapter{Scalaness/Mininess Implementation}
\label{chapter-scalaness-mininess-implementation}

\note{Include something useful.}

\section{Mininess}
\label{section-mininess-implementation}

\lstset{language=nesC}
\lstMakeShortInline!

The second stage language used by the system described here is a reduced dialect of nesC that I
call Mininess. Unlike full nesC, Mininess is restricted in a way that allows one to make a
stronger statement of the language's type and memory safety. \note{Be specific} In this respect
Mininess closely follows \newterm{nesT}, a theoretical language described in \cite{XXX}.
However, Mininess is not exactly the same as nesT in certain respects. \note{Be specific}

Mininess is implemented as a rewritting to ordinary nesC. Since Mininess is approximately a
subset of nesC this rewriting is largely trivial. However, certain aspects of Mininess are
different than nesC, in particular structure subtyping, safe casts, and array operations. In
this section I describe in detail how these features are rewritten.

In this section I will describe the design of Mininess with a focus on how it differs from nesC
and from nesT. Roughly Mininess is a practical implementation of nesT that can be compiled with
an ordinary nesC compiler.

The description that follows assumes the reader is familiar with nesC.

% TODO: I need to describe the Mininess subset somewhat exhaustively and carefully.
\subsection{Component Specifications}
\label{section-component-specifications-implementation}

In Mininess components (after specialization) present interfaces that are sequences of imports
and exports. The imports are implemented as nesC commands that are ``used'' by the component and
the exports are implemented as nesC commands that are ``provided'' by the component. NesC-style
events are not part of Mininess but can be simulated using commands.

% TODO: The citation below should really be to the nesC specification.

Mininess does not provide separate interfaces as nesC does. Instead all interaction with other
components is done by way of separately declared commands. These bare commands can be wired
together in the usual way by the nesC compiler \cite{Gay-nesC-2003}. This approach follows nesT
as described in in \cite{FramedML,nesT}. \autoref{figure-example-mininess} shows a simple
example of a Mininess module that interacts with a timer. Instead of using an interface with an
event, the module provides a callback command.

\singlespace
\begin{fpfig}[tbhp]{Example Mininess Module}{figure-example-mininess}
{
\begin{lstlisting}[language=nesC]
module ExampleC {
    uses command void setPeriodic(uint32_t period);
    provides command void fired();
}
implementation {
    // Written in the Mininess subset.
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

A Mininess code base consists of a collection of nesC modules. These modules do not by
themselves constitute a complete program. It is the job of the first stage Scalaness program to
compose Mininess modules, along with supporting components written in full nesC, into full
applications.

Mininess currently does not support nesC-like configuration components, although such support
could be added without significantly changing the system. The Scalaness program that composes
and specializes Mininess modules is responsible for generating the application's top level (and
only) configuration. That configuration defines how the modules are wired together. \note{Say
  something about what happens when Scalaness is used on only a portion of the application}

The only units of Mininess code that Scalaness programs are allowed to manipulate are entire
Mininess modules. The component oriented nature of nesC makes this level of granularity both
sufficient and appropriate. There is no need for the first stage program to manipulate, for
example, individual Mininess functions or Mininess expressions. Also module level granularity is
easier for both the implementation of Scalaness and it's theoretical development. \note{Why?}

Each Mininess module has a nesT module type implied by its specification element list. The
handling of this module type is described in more detail in Section~\ref{XXX}.

\subsection{External Libraries}
\label{section-external-libraries-design}

My experiments with Mininess show that it is expressive enough to write useful program
components. However, any realistic application will need to interact with various libraries
written in full nesC that I call \newterm{external libraries}. It is not my intention to require
the whole program be written in Mininess and generated by Scalaness. These libraries could
represent lower level code such as the TinyOS operating system or represent higher level
application code that wishes to use Scalaness generated Mininess modules.

Neither Mininess nor Scalaness provide any direct support for interfacing to external libraries.
However, a programming technique can be used whereby shim components are manually created that
wrap library interfaces.

As an example, consider the TinyOS \lstinline!Boot! interface. This interface is used to
indicate when a node is started; all useful nesC programs must interact with it. Yet Mininess
does not support interfaces at all much less some of the entities, such as events, that are
commonly declared in nesC interfaces. Instead the programmer creates a shim component such as
\lstinline!BootShimC! as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=nesC]
module BootShimC {
    uses command void booted( );
    uses interface Boot;
}
implementation {
    event void Boot.booted( )
    {
        call booted( );
    }
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The shim component is legal nesC but not legal Mininess. Its purpose is to expose all the
commands and events in an external library interface as bare commands. To this end wrapper
command and event implementations must be manually created.

Although creating shim components is a burden their form is highly stylized. Conceivably a tool
could be created that generates them automatically. A future version of the Scalaness compiler
may perform this function. However, some shim components are complex and must do additional
transformations on command arguments to interface with the non-Mininess external library
commands. In any case, shim components can be reused across Mininess applications. I expect
programmers to accumulate a library of such shims.

The shim components must be wired to the external library components they wrap. This is done by
producing two standard nesC configurations. The first, conventionally called
\lstinline!LibraryIC! encapsulates all full nesC components that have imports. The second,
conventionally called \lstinline!LibraryEC! encapsulates all full nesC components that have
exports. Normally these are the only two configurations an application needs. If the programmer
has full control over the entire application he or she can add the necessary external library
components (via their shims) to either \lstinline!LibraryIC! or \lstinline!LibraryEC! as
appropriate.

For example, \autoref{figure-libraryic} shows an example \lstinline!LibraryIC! component for a
hypothetical application that uses the external \lstinline!MainC! component and a specific
instance of the generic timer module, both from the TinyOS library. \note{Probably need to say
  something more about how generic modules are handled}

\singlespace
\begin{fpfig}[tbhp]{Example LibraryIC configuration}{figure-libraryic}
{
\begin{lstlisting}[language=nesC]
configuration LibraryIC {
    uses command void booted( );
    uses command void fired( );
}
implementation {
    components MainC, BootShimC, SpecificTimerC;

    BootShimC.booted = booted;
    BootShimC.Boot   -> MainC;

    SpecificTimerC.fired = fired;
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

Mininess does not (currently) support nesC configurations but Scalaness does allow the component
such as the one shown in \autoref{figure-libraryic} to be declared and manipulated in Scalaness
code. Such components are represented as Scala objects that extend the
\lstinline!MininessComponent! trait as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=scalaness]
object LibraryIC extends MininessComponent {
  external("LibraryIC.nc")
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The module type of this component can't be determined by examining its nesC definition since it
is not necessarily in the Mininess subset of nesC. Instead the module type on such external
components must be annotated by the programmer as described in XXX, and is accepted without
question by the Scalaness compiler.

In a typical program there are two such objects created, one representing the
\lstinline!LibraryIC! configuration and one representing the \lstinline!LibraryEC!
configuration. These objects are then manipulated in the usual way by the Scalaness program.

Although it is not possible to use Scalaness to compose external library components directly,
the programmer is free to create several different wrapping configurations if desired and
represent each of them separately in the Scalaness program. The Scalaness program could then
dynamically select which wrapping configuration is to be used in the final generated code. In
any case the type system will ensure that illegal wirings can never be made.

\subsection{Structure Subtyping}
\label{section-structure-subtyping-implementation}

\note{Include something useful here}

\subsection{Safe Casts}
\label{section-safe-casts-implementation}

Initialization and assignments are implicitly allowed if the expression on the right hand side
of the operation has a subtype of the l-value on the left hand side. Actual type conversions
(casts) must all be explicit and are only allowed as provided by user configuration described in
\autoref{section-safe-casts-design}.

To illustrate the way these casts are implemented in Mininess programs consider as an example
the following two structure definitions.

\singlespace
\begin{lstlisting}[language=nesC]
struct UserInfo {
    char name[25];
    int  age;
    int  id;
};

struct UserToken {
    int id;
    int hash;
};
\end{lstlisting}
\primaryspacing

The developer may wish to allow an object of type !UserInfo! to be explicitly cast into an
object of type !UserToken!. Once the Scalaness compiler determines that this is legal it
rewrites each cast expression into a call of an appropriately named conversion command. These
conversion commands exist in an interface !DoCast!. For example

\singlespace
\begin{lstlisting}[language=nesC]
token = (struct UserToken)user;

// ... rewritten to ...

token = (call DoCast.UserInfo_UserToken(user));
\end{lstlisting}
\primaryspacing

The developer is required to provide the !DoCast! interface and a component !DoCastC! that
provides that interface and contains an implementation of the various conversion commands
needed.

Since one of the goals of Mininess is to promote type safety, no implicit converstion operations
are provided. Assignment and initialization from a subtype to a supertype is permitted and
explicit casts are permitted only when configured by the programmer. This allows the programmer
to disallow casts that are unsafe or illogical while also supporting casts that are logical even
if they require non-trivial user defined code to execute.

The Scalaness compiler accepts a configuration file that defines a relation on types
\textit{isCompatible}. If \textit{isCompatible($T_1$, $T_2$)} is true then it is permitted to
cast an expression of type $T_1$ into an expression of type $T_2$. There are no restrictions on
the types $T_1$ and $T_2$.

By giving the developer explicit control over casts, conventional type conversions are permitted
without compromising the logical consistency of the program. Furthermore all such conversions
require explicit cast expressions; they are never applied implicitly.

The implementation of each allowed cast operation is made manifest by a command written by the
developer. This is described more in \autoref{section-safe-casts-implementation}.

% TODO: What about conversions between types that are type parameters?

\subsection{Array Operations}
\label{section-array-operations-implementation}

Each expression !a! of array type !Array(T)! has a corresponding hidden dynamic value
representing the size of the array. Expressions of the form !a |> e! can nominally be rewritten
to nesC using pointer arithmetic as !( (a) + (e) )!. Let $n$ be the dynamic size of expression
!a!, then $n_e$ the dynamic size of !a |> e! is $n_e = n - e$. This size might be negative but
any use of an array expression with a negative size results in a run time error \emph{at the
  point of use}.

A statement containing one or more array increment expressions or array indexing expressions is
rewritten as a block enclosed sequence of statements containing compiler generated local
variables for the dynamic sizes of the temporary arrays along with appropriate run time checks.

For each array increment operation $a_i \rhd e_i$ in a statement a variable to hold the value of
$e_i$ is declared and initialized. This is done so that $e_i$ will only be evaluated once; an
important considering in a language, such as nesC, with side effects. Also the dynamic size of
the result of each array operation $d_i$ is declared and initialized appropriately. For example

\singlespace
\begin{lstlisting}[language=nesC]
... (a |> e) ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e;
  int __d_1 = __d_0 - __e_1;

  ... ((a) + __e_1) ...
}
\end{lstlisting}
\primaryspacing

Here !__d_0! is the dynamic size associated with the array expression !a!. In the common case
where !a! is a declared array the size will be known statically and an appropriate constant can
be used instead of a reference to a dynamic size variable.

For each array indexing operation $a_i[e_i]$ in a statement a variable to hold the value of
$e_i$ is declared and initialized, as before. A run time check is inserted to ensure that
the value of $e_i$ is inside the dynamic size of $a_i$. For example

\singlespace
\begin{lstlisting}[language=nesC]
... a[n] ...
\end{lstlisting}
\primaryspacing

Is rewritten without regard to any possible optimizations as

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = n;
  if (__e_1 >= __d_0) error( );
  ... a[__e_1] ...
}
\end{lstlisting}
\primaryspacing

As before !__d_0! is the dynamic size associated with the array expression !a!.

In a statement involving multiple array operations, each operation is rewritten as described
above one at a time. After the first operation is rewritten, the enclosed modified statement is
further expanded with the second rewriting. The checks are issues in the order they are
encountered during a depth first left to right traversal of the Mininess abstract syntax tree.
For example a statement such as

\singlespace
\begin{lstlisting}[language=nesC]
x = ((a |> e1) |> e2)[b[i]];
\end{lstlisting}
\primaryspacing

Is first rewritten as:

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  x = (((a) + __e_1) |> e2)[b[i]];
}
\end{lstlisting}
\primaryspacing

The resulting statement still contains three array operations. The second stage of rewriting
yields

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    x = ( ((a) + __e_1) + __e_2 )[b[i]];
  }
}
\end{lstlisting}
\primaryspacing

The inner indexing operation is then rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      x = ( ((a) + __e_1) + __e_2 )[b[__e_3]];
    }
  }
}
\end{lstlisting}
\primaryspacing

Finally, the outer indexing operation is rewritten

\singlespace
\begin{lstlisting}[language=nesC]
{
  int __e_1 = e1;
  int __d_1 = __d_0 - __e_1;
  {
    int __e_2 = e2;
    int __d_2 = __d_1 - __e_2;
    {
      int __e_3 = i;
      if (__e_3 >= __d_b) error( );
      {
        int __e_4 = b[__e_3];
        if (__e_4 >= __d_2) error( );
        x = ( ((a) + __e_1) + __e_2 )[__e_4];
      }
    }
  }
}
\end{lstlisting}
\primaryspacing

% Notice that declarations can't be enclosed in the block without changing the scope of the
% identifiers they declare. Thus array expressions used in the initialization of a variable
% present a special problem. It might be necessary to first split initializers off from their
% declarations in a separate AST processing pass.

Functions declared to take an array as a parameter are rewritten to so that the dynamic size of
the array is passed as an additional parameter. This parameter becomes the $d$ of array
expressions involving only the parameter. Calls to such functions are rewritten to pass the
additional dynamic size information as appropriate.

% TODO: Need to talk about how the errors are handled.

\lstDeleteShortInline!

\section{Scalaness}
\label{section-scalaness-implementation}

\lstset{language=scalaness}
\lstMakeShortInline!

Scalaness is implemented as a modified Scala compiler based on the development Scala compiler on
GitHub \cite{XXX}. I note that the Scala compiler has a plugin architecture and so it is
reasonable to wonder if Scalaness could be implemented as a plugin. In fact the plugin option
has the advantages of being easier to use and potentially easier to manage during development.

However, early experience attempting to implement Scalaness as a compiler plugin met with
difficulties. The main problem was with extending the typing rules of Scala. The plugin approach
seemed to require me to, essentially, reimplement Scala typing inside the plugin. This was
because plugins can only gain control either before Scala typing has occurred or after it has
completed. Thus the implementation of the nesT typing rules couldn't easily benefit from the
logic in the existing type checker. In contrast building Scalaness as a modified compiler
allowed me to ``piggyback'' on the existing type checker and get proper handling of most typing
cases ``for free.''

Yet in order to facilitate keeping Scalaness synchronized with future developments of the main
Scala compiler I made every attempt to implement Scalaness in the least invasive way possible.
Much of the logic, including the nesT typing rules themselves are implemented in separate
packages away from the main body of the standard compiler codebase. The places where it was
necessary to insert Scalaness specific code into, for example, the existing type checker, have
been kept to a minimum.

One consequence of this philosophy is that radical changes to Scala syntax were not seriously
considered. I didn't want to modify \emph{both} the parser and the type checker if I could avoid
it. Fortunately Scala has a general mechanism for adding arbitrary information to declarations,
namely \newterm{annotations}. Thus I used Scala annotations to express nesT module types as
strings using a syntax of my choosing.

My work is based on Scala 2.10. This version of Scala also provides an extensive reflection API
and experimental support for expression macros. These facilities allow one to do AST
transformations on Scala programs using ordinary (macro) Scala code. Macros are described by the
Scala community as a kind of ``lightweight'' plugin mechanism. Unfortunately at the time of this
writing type macros are not available so it is not yet possible to write a macro that outputs a
class definition. However, in the future when type macros become available it might be possible
to implement some or all of Scalaness as a macro library.

\subsection{Scala Compiler Organization}
\label{section-scala-compiler-organization}

The Scala compiler is organized as a number of phases that rewrite the input in successive steps
lowering it to the target's machine code (JVM bytecode). The precise phases used can be listed
with the command \texttt{scalac -Xshow-phases}. Of primary significance to Scalaness are the
first four phases used by the stock Scala compiler. These phases are shown below.

\singlespace
\begin{Verbatim}
parser
namer
packageobjects
typer
...
\end{Verbatim}
\primaryspacing

The bulk of the modifications made by Scalaness are in the typer phase. There hooks where added
at critical points that call into Scalaness specific code in package !uvm.edu.scalaness!. In
addition a new phase was added between the parser and namer phases. This new phase,
\texttt{scalanesspostparser}, is responsible for augmenting certain Scalaness constructs with
their necessary runtime support. This is done by inserting new material in the AST produced by
the parser. In principle that material could have been manually written by the programmer but
instead is automatically generated as a convenience. It is this postparser phase that could
potentially be eliminated by type macros when they become available.

\subsection{Liftable Types}
\label{section-liftable-types-design}

Certain types that appear in a Scalaness program correspond to types in the Mininess components
manipulated by that program. These types are said to be \textit{liftable}. Values of these types
can be computed in the Scalaness program and then used to specialize Mininess components. These
values need to be transformed as they cross the boundary between the two programming languages
in response to differences in the way a liftable type and its Mininess counterpart are
represented. In this section I will describe which Scalaness types are liftable and how their
values are handled when used to specialize a Mininess component.

\subsubsection{Primitive Types}
\label{section-primitive-types-design}

All liftable types are subtypes of a special marker trait !NesCType!. The primitive types in
Mininess have liftable counterparts in Scalaness that are classes extending !NesCType!. These
classes and their corresponding Mininess types are shown in \autoref{table-primitive-liftable}.

\begin{table}
  \centering
  \caption{Primitive Liftable Types}
  \label{table-primitive-liftable}
  \begin{tabular}{|l|l|} \hline
    \textit{Scalaness Type} & \textit{Mininess Type} \\ \hline
    Uninit & void      \\ \hline
    Char   & char      \\ \hline
    UInt32 & uint32\_t \\ \hline
    UInt16 & uint16\_t \\ \hline
    UInt8  & uint8\_t  \\ \hline
    Int32  & int32\_t  \\ \hline
    Int16  & int16\_t  \\ \hline
    Int8   & int8\_t   \\ \hline
  \end{tabular}
\end{table}

The Mininess subtype relations are preserved in Scalaness where !UInt8 <: UInt16 <: UInt32! and
similarly for the signed integer types. In Scalaness these types are defined in the object
!LiftableTypes! so that they don't conflict with any normal (non-liftable) types defined by the
programmer or the language, such as !Char!. Furthermore the integer liftable types are endowed
with the usual arithmetic operations so they can be manipulated in the Scalaness program in a
natural way.

No conversions are provided between the liftable types and their ordinary Scala analogs. This
means existing libraries that, for example, manipulate Scala !Char! objects won't work with
!LiftableTypes.Char!. I do not consider this a problem for two reasons.
\begin{enumerate}
\item Since values of liftable type will eventually be written into Mininess modules, they will
  likely be put to very different uses than values of ordinary Scala type.
\item Conversions (including implicit conversions) can be easily added by the Scalaness
  programmer if desired using the normal facilities of Scala.
\end{enumerate}

To facilitate the second point, explicit conversion methods from each liftable type to its
obvious non-liftable counterpart are provided.

% TODO: The following two paragraphs should be moved to the Scalaness-Implementation section.

The Scala type system is used to ensure compile-time type safety of the primitive liftable types
in a Scalaness program. For example the type !Int16! can only be constructed using a value of
Scala's type !Short!. Consequently normal Scala type checking prevents a potentially out of
range value from being used.

Unfortunately Scala does not support unsigned types natively. In the current implementation a
sufficiently wide signed type is used to initialize objects of unsigned liftable type. This
makes it possible to use an out-of-range value during the execution of the Scalaness program
resulting in a runtime exception. I don't believe this can be avoided without adding support for
unsigned types to the Scala compiler.

\subsubsection{Arrays}
\label{section-arrays-design}

\subsubsection{Structures}
\label{section-structures-design}

A Scala class $C$ that extend the !NesCType! trait is liftable to a Mininess structure type
provided it additionally obeys the following inductive rules.

\begin{enumerate}
\item $C$ is not generic.
\item All of $C$'s fields have liftable type.
\item All of $C$'s supertypes (except !AnyRef! and !ScalaObject!) are liftable types.
\end{enumerate}

In this case $C$ is said to be a \textit{liftable class}. Except for the rules mentioned here
there are no restrictions on the definition or use of liftable classes. In particular, they are
able to have convenience methods, although the methods of a liftable class have no manifestation
in the generated Mininess code.

For example, consider the following Scalaness code:

\singlespace
\begin{lstlisting}[language=scalaness]
class Header
 (val nodeID      : nodeIDType,
  val componentID : UInt8 ) extends NesCType

class TimeStampedHeader
 (val timeStamp   : UInt16) extends Header
\end{lstlisting}
\primaryspacing

Here !nodeIDType! is a previously defined liftable class type. Consequently both of these
classes are liftable and have representations as Mininess structure types. \note{TODO: Figure
  out how to properly model Scala's inheritance system in this context.}

\subsection{Component Definition}
\label{section-component-definition}

Modules in Mininess can be parameterized by types and values and instantiated multiple times.
These properties are closely modeled by Scala classes. Thus the representation of a Mininess
module in Scalaness is by way of a class that extends a special marker trait.

One might be tempted to allow a syntax such as

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) extends NesCCompont {

  import error_t radio(MessageT *);
  export error_t send( Adt addr, uint8_t *data ) {
    MessageT packet = { self, addr, data };
    radio( &packet );
    return SUCCESS;
  }
}
\end{lstlisting}
\primaryspacing

This defines a Scalaness component using Scala syntax for representing type and value
parameters. The body of the component, however is written in Mininess. Unfortunately this can't
be supported by a compiler plugin because Mininess is too "alien" for the Scala parser to
accept.

One way to work around this is presented in \cite{Garcia-Scala-Query} where the alien language
is included as a string literal. The Scala typer will treat the Mininess program as having type
String but the plugin could parse the string's contents (provided it requires it to be a
literal) and impose additional typing rules on those contents. However, this approach leads to a
rather ungainly programming style:

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "import error_t radio(MessageT *);"                +
  "export error_t send( Adt addr, uint8_t *data ) {" +
  "  MessageT packet = { self, addr, data };"        +
  "  radio( &packet );"                              +
  "  return SUCCESS;"                                +
  "}"
}
\end{lstlisting}
\primaryspacing

Instead my implementation uses a string literal to name an external file containing the Mininess
inclusion.

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "SendC.nc"
}
\end{lstlisting}
\primaryspacing

Conceptually the contents of the named file replace the literal name in the Scalaness program.
However, this approach allows the normal Scala parser and type checker to process the program
successfully. This also allows the programmer to develop the Mininess material in an editor that
is more suitable for nesC. Scalaness programs will, presumably, be developed using a Scala
oriented tool. Such tools will not understand the Mininess inclusion and won't be able to
provide any support for it such as syntax highlighting or automatic indentation.

The Scalaness plugin would, of course, locate the file \filename{SendC.nc}, and parse and
typecheck its contents in the desired way. Notice that, as expected, the scope of the parameters
Adt, MessageT, and self extend to the contents of \filename{SendC.nc}.


\subsection{Component Operations}

In this section I describe how the Scalaness-level operations on Mininess components are
implemented. There are two basic operations to consider: component composition and component
instantiation.

\subsubsection{Composition}

\textit{blah, blah, blah}

Before delving into the details of how the conversion to nesC works, I will start with a simple
example. Below is the Scalaness runtime representation of three Mininess components, each as an
instance of class NamedProgramComponent.

\singlespace
\begin{lstlisting}[language=scalaness]
val A = new NamedProgramComponent(
  name            = "A",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set("c1", "c2"),
  exports         = Set())

val B = new NamedProgramComponent(
  name            = "B",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set(),
  exports         = Set("c1"))

val C = new NamedProgramComponent(
  name            = "C",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set("c1"),
  exports         = Set("c2"))
\end{lstlisting}
\primaryspacing

The parameters, imports, and exports are all represented (for now) as sets of strings. In this
example A uses commands c1 and c2, B provides command c1, etc.

These components can be composed as follows:

\singlespace
\begin{lstlisting}[language=scalaness]
val composedComponent1 =
  A.toProgramComponent + B.toProgramComponent

val composedComponent2 =
  composedComponent1 + C.toProgramComponent

composedComponent2.display(outputFile)
\end{lstlisting}
\primaryspacing

The code above is plain Scala. The Scalaness programmer would use a more convenient syntax but
the compiler, essentially, rewrites that syntax into the above. The first stage program executes
with a Scalaness runtime support library that provides the necessary classes and related
infrastructure to make such code work as intended.

A, B, and C are NamedProgramComponents. These are the components defined by the Scalaness
programmer. Internally, however, all operations on components are done using anonymous
components from class ProgramComponent. I describe the reasons for this more fully below. The
method toProgramComponent is a conversion operator. The method '+' is overloaded here to do
component composition.

In the example above the material that is written to the outputFile is:

\singlespace
\begin{lstlisting}[language=nesC]
configuration AppC {
    provides c1;
    provides c2;
}
implementation {
    components A, B, C;
    A.c1 -> B.c1;
    A.c2 -> C.c2;
    C.c1 -> B.c1;
}
\end{lstlisting}
\primaryspacing

There are two kinds of components: those with names and those that are anonymous. Anonymous
components are the result of component composition and can contain a collection of named
components embedded inside of them. The imports and exports of a component are maps that
associate the name of the import or export with the embedded named component that uses or
provides it, respectively. A conversion exists from named to anonymous components. That
conversion returns an anonymous component that has the (one) named component embedded inside of
it.

The types used to represent imports and exports are as shown below.

\singlespace
\begin{lstlisting}[language=scalaness]
type ImportsType =
  Map[String, List[NamedProgramComponent]]

type ExportsType =
  Map[String, NamedProgramComponent]

type WireType =
  (String, NamedProgramComponent, NamedProgramComponent)
\end{lstlisting}
\primaryspacing

The ImportsType maps an overall import name to a list of NamedProgramComponents because, after
composition the same import might be used by more than one embedded component. That is not the
case for exports since exports are combined with a mutually exclusive map merge. Each overall
export can thus be provided by exactly one embedded component.

The type WireType is used to represent the "wires" between embedded components. It is a triple
where the first element is the name of the command being wired and the other two elements are
the wire endpoints (user first).

In addition each (anonymous) ProgramComponent contains a ProgramConfiguration member. This
configuration describes the embedded components and the nesC wiring used to connect them.

ProgramComponents are immutable instances from the following class

\singlespace
\begin{lstlisting}[language=scalaness]
class ProgramComponent(
  private val typeParameters: Set[String],
  private val termParameters: Set[String],
  private val imports       : ImportsType,
  private val exports       : ExportsType,
  private val configuration : ProgramConfiguration) { ...
\end{lstlisting}
\primaryspacing

\subsubsection{Instantiation}

Unfortunately normal Scala class instantiation isn't enough to instantiate Mininess components.
This is because Scalaness allows types to be treated as first class values and such \textit{type
  values} can be used as the type arguments of a Mininess module. To support types as values it
is necessary to introduce a generic class that wraps a representation of a nesC type

\singlespace
\begin{lstlisting}[language=scalaness]
class MetaType[+Tau <: LiftableTypes.NesCType]
  (val wrappedType: NesCTypes.TypeRepresentation)
    extends LiftableTypes.NesCType
\end{lstlisting}
\primaryspacing

Objects of type \inlinecode{MetaType} contain a representation of a nesC type. They are
covariently parameterized by an upper bound type. Note that \inlinecode{MetaType}'s type
parameter is a Scala type that is liftable to nesC. However the type it wraps is the already
lifted type. Thus \inlinecode{MetaType} objects form a bridge between the Scala and nesC sides
of the system.

A module such as

\singlespace
\begin{lstlisting}[language=scalaness]
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

Is modified by the Scalaness plugin to hold some additional fields and methods

\singlespace
\begin{lstlisting}[language=scalaness]
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  /////////
  // Code generated by the Scalaness compiler.
  /////////
  var AType: MetaType[Int32] = null
  def getTypeMap  = Map("A" -> AType)
  def getValueMap = Map("period" -> period)
  ////////
  // END of Scalaness generated code.
  ////////

  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

The generated field \inlinecode{AType} holds a reference to the type used to instantiate the
module. In Scalaness this type can only be known at runtime. The methods \inlinecode{getTypeMap}
and \inlinecode{getValueMap} are used during module specialization. The method that does so is
inherited from \inlinecode{NesCComponent} but it calls these methods through their abstract
interface.

Notice that at the Scala level the type parameter must be some type that extends
\inlinecode{LiftableTypes.Int32} (in this example). However, when the module is instantiated the
Scalaness programmer might provide a variable of type \inlinecode{MetaType[Int32]}. For example

\singlespace
\begin{lstlisting}[language=scalaness]
val desiredType: MetaType[Int32] = ...
val blinkModule = new BlinkC[desiredType](new Int8(100))
\end{lstlisting}
\primaryspacing

The Scala parser will accept this construction but the Scala type checker will reject the use of
a val as a type argument. Thus expressions involving component instantation are rewritten during
the post-parser phases into

\singlespace
\begin{lstlisting}[language=scalaness]
val blinkModule = {
  val temp = new BlinkC[Int32](new Int8(100))
  temp.AType = desiredType
  temp
}
\end{lstlisting}
\primaryspacing

Unfortunately this rewritting is difficult because of the minimal amount of information
available to the plugin immediately after parsing.

\lstDeleteShortInline!

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
