
\chapter{Conclusion}
\label{chapter-conclusion}

% Getting a Ph.D. is a major pain in the ass.

This dissertation has described two language-level approaches for providing trust management
style authorization to resource constrained embedded systems. One approach, SpartanRPC, is based
on a remote procedure call discipline with primitives for specifying authorization requests and
requirements. The other approach, Scalaness, makes use of staged programming to off-load
complicated security computations to a higher powered machine.

In addition to describing the design of SpartanRPC and Scalaness, this dissertation has also
demonstrated implementations of both and shown their application to a realistically scaled
sensor network system.

As a method for providing distributed trust management to resource constrained systems, both
approaches are feasible. SpartanRPC does demand considerable resources on the devices, limiting
the amount of memory and processor time available for application logic. However, in some
environments these limitations may be acceptable. Scalaness has the potential of greatly
reducing the load on the embedded devices but requires a deployment scenario where a more
powerful machine is available to specialize the device programs.

Both approaches are tied to the nesC programming language either by extending nesC in the case
of SpartanRPC or by translating a specialized language into nesC in the case of Scalaness.
However, the systems described here are not specific to sensor networks and would be applicable
in any environment where nesC is used. Furthermore, although nesC was developed for sensor
networks, it could be used as a general purpose embedded systems language.

Scalaness also has the advantage of being a far more flexible system than SpartanRPC. Staging
could be applied to a variety of problems, not just the handling of security and authorization.
In that respect Scalaness is a more general tool and thus potentially of greater long term
interest.

\section{Future Work}
\label{section-future-work}

Possible future directions of this work can be divided into two broad categories: generalizing
the systems and providing additional safety guarantees.

The Sprocket implementation of SpartanRPC is already modular enough to support alternate (and
even multiple, simultaneous) authorization mechanisms. It would be interesting to experiment
with richer trust management languages such as $RT_1$ and its variations to see how expressive a
trust management language could be supported on constrained devices. Currently the $RT_0$
authorization logic uses minimal time and space so conceivably fairly complex trust management
languages could be supported without significantly increasing the overall overhead of the
system.

Notice that the current version of Scalaness already supports arbitrary trust management
languages because the first stage program runs in an environment with relatively infinite
resources.

Sprocket currently supposes that neighboring nodes communicate over a radio link. However, this
assumption is only reflected in the code generated by Sprocket for the stubs and skeletons. It
would be a simple engineering matter to modify Sprocket to generate stubs and skeletons for some
other communication technology such as TCP/IP or the Controller Area Network (CAN) bus widely
used in automotive embedded systems \cite{pazul1999controller}.

SpartanRPC is, however, closely tied to nesC because of the way it defines and uses dynamic
wires. In contrast, the current implementation of Scalaness formally translates nesT to nesC as
it generates the second stage program. This final translation step could be modified to produce
a different language, such as C, with no change to the foundational semantics. This would make
the system applicable to a larger group of embedded developers.

The type safety guarantee provided by Scalaness is valuable but embedded systems have other
correctness needs as well. Many embedded systems are used in safety critical applications where
assurance of freedom from runtime errors, such as array bounds overflow, is essential. Systems
exist that can analyze Ada or C programs to prove freedom from such errors
\cite{Barnes:2000:SWC:369264.369271,Cuoq:2012:FSA:2404232.2404250} and those systems could
conceivably be applied to the output of Scalaness now. However, it would be an interesting and
challenging direction for future work to extend Scalaness so the programmer could be assured
that \emph{all possible} generated programs were free of important classes of runtime errors.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
