\chapter{Scalaness Implementation}
\label{chapter-scalaness-implementation}

\lstset{language=scalaness}
\lstMakeShortInline!

Scalaness is implemented as a modified Scala compiler based on the development Scala compiler on
GitHub \cite{XXX}. I note that the Scala compiler has a plugin architecture and so it is
reasonable to wonder if Scalaness could be implemented as a plugin. In fact the plugin option
has the advantages of being easier to use and potentially easier to manage during development.

However, early experience attempting to implement Scalaness as a compiler plugin met with
difficulties. The main problem was with extending the typing rules of Scala. The plugin approach
seemed to require me to, essentially, reimplement Scala typing inside the plugin. This was
because plugins can only gain control either before Scala typing has occurred or after it has
completed. Thus the implementation of the nesT typing rules couldn't easily benefit from the
logic in the existing type checker. In contrast building Scalaness as a modified compiler
allowed me to ``piggyback'' on the existing type checker and get proper handling of most typing
cases ``for free.''

Yet in order to facilitate keeping Scalaness synchronized with future developments of the main
Scala compiler I made every attempt to implement Scalaness in the least invasive way possible.
Much of the logic, including the nesT typing rules themselves are implemented in separate
packages away from the main body of the standard compiler codebase. The places where it was
necessary to insert Scalaness specific code into, for example, the existing type checker, have
been kept to a minimum.

One consequence of this philosophy is that radical changes to Scala syntax were not seriously
considered. I didn't want to modify \emph{both} the parser and the type checker if I could avoid
it. Fortunately Scala has a general mechanism for adding arbitrary information to declarations,
namely \newterm{annotations}. Thus I used Scala annotations to express nesT module types as
strings using a syntax of my choosing.

My work is based on Scala 2.10. This version of Scala also provides an extensive reflection API
and experimental support for expression macros. These facilities allow one to do AST
transformations on Scala programs using ordinary (macro) Scala code. Macros are described by the
Scala community as a kind of ``lightweight'' plugin mechanism. Unfortunately at the time of this
writing type macros are not available so it is not yet possible to write a macro that outputs a
class definition. However, in the future when type macros become available it might be possible
to implement some or all of Scalaness as a macro library.

\section{Scala Compiler Organization}
\label{section-scala-compiler-organization}

The Scala compiler is organized as a number of phases that rewrite the input in successive steps
lowering it to the target's machine code (JVM bytecode). The precise phases used can be listed
with the command \texttt{scalac -Xshow-phases}. Of primary significance to Scalaness are the
first four phases used by the stock Scala compiler. These phases are shown below.

\singlespace
\begin{Verbatim}
parser
namer
packageobjects
typer
...
\end{Verbatim}
\primaryspacing

The bulk of the modifications made by Scalaness are in the typer phase. There hooks where added
at critical points that call into Scalaness specific code in package !uvm.edu.scalaness!. In
addition a new phase was added between the parser and namer phases. This new phase,
\texttt{scalanesspostparser}, is responsible for augmenting certain Scalaness constructs with
their necessary runtime support. This is done by inserting new material in the AST produced by
the parser. In principle that material could have been manually written by the programmer but
instead is automatically generated as a convenience. It is this postparser phase that could
potentially be eliminated by type macros when they become available.

\section{Component Definition}
\label{section-component-definition}

Modules in Mininess can be parameterized by types and values and instantiated multiple times.
These properties are closely modeled by Scala classes. Thus the representation of a Mininess
module in Scalaness is by way of a class that extends a special marker trait.

One might be tempted to allow a syntax such as

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) extends NesCCompont {

  import error_t radio(MessageT *);
  export error_t send( Adt addr, uint8_t *data ) {
    MessageT packet = { self, addr, data };
    radio( &packet );
    return SUCCESS;
  }
}
\end{lstlisting}
\primaryspacing

This defines a Scalaness component using Scala syntax for representing type and value
parameters. The body of the component, however is written in Mininess. Unfortunately this can't
be supported by a compiler plugin because Mininess is too "alien" for the Scala parser to
accept.

One way to work around this is presented in \cite{Garcia-Scala-Query} where the alien language
is included as a string literal. The Scala typer will treat the Mininess program as having type
String but the plugin could parse the string's contents (provided it requires it to be a
literal) and impose additional typing rules on those contents. However, this approach leads to a
rather ungainly programming style:

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "import error_t radio(MessageT *);"                +
  "export error_t send( Adt addr, uint8_t *data ) {" +
  "  MessageT packet = { self, addr, data };"        +
  "  radio( &packet );"                              +
  "  return SUCCESS;"                                +
  "}"
}
\end{lstlisting}
\primaryspacing

Instead my implementation uses a string literal to name an external file containing the Mininess
inclusion.

\singlespace
\begin{lstlisting}[language=scalaness]
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "SendC.nc"
}
\end{lstlisting}
\primaryspacing

Conceptually the contents of the named file replace the literal name in the Scalaness program.
However, this approach allows the normal Scala parser and type checker to process the program
successfully. This also allows the programmer to develop the Mininess material in an editor that
is more suitable for nesC. Scalaness programs will, presumably, be developed using a Scala
oriented tool. Such tools will not understand the Mininess inclusion and won't be able to
provide any support for it such as syntax highlighting or automatic indentation.

The Scalaness plugin would, of course, locate the file \filename{SendC.nc}, and parse and
typecheck its contents in the desired way. Notice that, as expected, the scope of the parameters
Adt, MessageT, and self extend to the contents of \filename{SendC.nc}.


\section{Component Operations}

In this section I describe how the Scalaness-level operations on Mininess components are
implemented. There are two basic operations to consider: component composition and component
instantiation.

\subsection{Composition}

\textit{blah, blah, blah}

Before delving into the details of how the conversion to nesC works, I will start with a simple
example. Below is the Scalaness runtime representation of three Mininess components, each as an
instance of class NamedProgramComponent.

\singlespace
\begin{lstlisting}[language=scalaness]
val A = new NamedProgramComponent(
  name            = "A",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set("c1", "c2"),
  exports         = Set())

val B = new NamedProgramComponent(
  name            = "B",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set(),
  exports         = Set("c1"))

val C = new NamedProgramComponent(
  name            = "C",
  typeParameters  = Set(),
  valueParameters = Set(),
  imports         = Set("c1"),
  exports         = Set("c2"))
\end{lstlisting}
\primaryspacing

The parameters, imports, and exports are all represented (for now) as sets of strings. In this
example A uses commands c1 and c2, B provides command c1, etc.

These components can be composed as follows:

\singlespace
\begin{lstlisting}[language=scalaness]
val composedComponent1 =
  A.toProgramComponent + B.toProgramComponent

val composedComponent2 =
  composedComponent1 + C.toProgramComponent

composedComponent2.display(outputFile)
\end{lstlisting}
\primaryspacing

The code above is plain Scala. The Scalaness programmer would use a more convenient syntax but
the compiler, essentially, rewrites that syntax into the above. The first stage program executes
with a Scalaness runtime support library that provides the necessary classes and related
infrastructure to make such code work as intended.

A, B, and C are NamedProgramComponents. These are the components defined by the Scalaness
programmer. Internally, however, all operations on components are done using anonymous
components from class ProgramComponent. I describe the reasons for this more fully below. The
method toProgramComponent is a conversion operator. The method '+' is overloaded here to do
component composition.

In the example above the material that is written to the outputFile is:

\singlespace
\begin{lstlisting}[language=nesC]
configuration AppC {
    provides c1;
    provides c2;
}
implementation {
    components A, B, C;
    A.c1 -> B.c1;
    A.c2 -> C.c2;
    C.c1 -> B.c1;
}
\end{lstlisting}
\primaryspacing

There are two kinds of components: those with names and those that are anonymous. Anonymous
components are the result of component composition and can contain a collection of named
components embedded inside of them. The imports and exports of a component are maps that
associate the name of the import or export with the embedded named component that uses or
provides it, respectively. A conversion exists from named to anonymous components. That
conversion returns an anonymous component that has the (one) named component embedded inside of
it.

The types used to represent imports and exports are as shown below.

\singlespace
\begin{lstlisting}[language=scalaness]
type ImportsType =
  Map[String, List[NamedProgramComponent]]

type ExportsType =
  Map[String, NamedProgramComponent]

type WireType =
  (String, NamedProgramComponent, NamedProgramComponent)
\end{lstlisting}
\primaryspacing

The ImportsType maps an overall import name to a list of NamedProgramComponents because, after
composition the same import might be used by more than one embedded component. That is not the
case for exports since exports are combined with a mutually exclusive map merge. Each overall
export can thus be provided by exactly one embedded component.

The type WireType is used to represent the "wires" between embedded components. It is a triple
where the first element is the name of the command being wired and the other two elements are
the wire endpoints (user first).

In addition each (anonymous) ProgramComponent contains a ProgramConfiguration member. This
configuration describes the embedded components and the nesC wiring used to connect them.

ProgramComponents are immutable instances from the following class

\singlespace
\begin{lstlisting}[language=scalaness]
class ProgramComponent(
  private val typeParameters: Set[String],
  private val termParameters: Set[String],
  private val imports       : ImportsType,
  private val exports       : ExportsType,
  private val configuration : ProgramConfiguration) { ...
\end{lstlisting}
\primaryspacing

\subsection{Instantiation}

Unfortunately normal Scala class instantiation isn't enough to instantiate Mininess components.
This is because Scalaness allows types to be treated as first class values and such \textit{type
  values} can be used as the type arguments of a Mininess module. To support types as values it
is necessary to introduce a generic class that wraps a representation of a nesC type

\singlespace
\begin{lstlisting}[language=scalaness]
class MetaType[+Tau <: LiftableTypes.NesCType]
  (val wrappedType: NesCTypes.TypeRepresentation)
    extends LiftableTypes.NesCType
\end{lstlisting}
\primaryspacing

Objects of type \inlinecode{MetaType} contain a representation of a nesC type. They are
covariently parameterized by an upper bound type. Note that \inlinecode{MetaType}'s type
parameter is a Scala type that is liftable to nesC. However the type it wraps is the already
lifted type. Thus \inlinecode{MetaType} objects form a bridge between the Scala and nesC sides
of the system.

A module such as

\singlespace
\begin{lstlisting}[language=scalaness]
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

Is modified by the Scalaness plugin to hold some additional fields and methods

\singlespace
\begin{lstlisting}[language=scalaness]
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  /////////
  // Code generated by the Scalaness compiler.
  /////////
  var AType: MetaType[Int32] = null
  def getTypeMap  = Map("A" -> AType)
  def getValueMap = Map("period" -> period)
  ////////
  // END of Scalaness generated code.
  ////////

  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

The generated field \inlinecode{AType} holds a reference to the type used to instantiate the
module. In Scalaness this type can only be known at runtime. The methods \inlinecode{getTypeMap}
and \inlinecode{getValueMap} are used during module specialization. The method that does so is
inherited from \inlinecode{NesCComponent} but it calls these methods through their abstract
interface.

Notice that at the Scala level the type parameter must be some type that extends
\inlinecode{LiftableTypes.Int32} (in this example). However, when the module is instantiated the
Scalaness programmer might provide a variable of type \inlinecode{MetaType[Int32]}. For example

\singlespace
\begin{lstlisting}[language=scalaness]
val desiredType: MetaType[Int32] = ...
val blinkModule = new BlinkC[desiredType](new Int8(100))
\end{lstlisting}
\primaryspacing

The Scala parser will accept this construction but the Scala type checker will reject the use of
a val as a type argument. Thus expressions involving component instantation are rewritten during
the post-parser phases into

\singlespace
\begin{lstlisting}[language=scalaness]
val blinkModule = {
  val temp = new BlinkC[Int32](new Int8(100))
  temp.AType = desiredType
  temp
}
\end{lstlisting}
\primaryspacing

Unfortunately this rewritting is difficult because of the minimal amount of information
available to the plugin immediately after parsing.

\lstDeleteShortInline!

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
