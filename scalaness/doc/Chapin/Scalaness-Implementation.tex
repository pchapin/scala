\chapter{Scalaness Implementation}
\label{chap:scalaness-implementation}

Scalaness is implemented as a Scala compiler plugin for Scala version 2.9. At the time work on
Scalaness started the only other option was to modify the compiler directly. The plugin option
was considered more desirable because both implementing and using a plugin is easier than
working with a modified compiler.

Unfortunately the current Scala compiler plugin architecture imposes a number of restrictions on
what can be accomplished in a plugin. Those restrictions require the Scalaness implementation to
make some compromises as compared with an ideal system. I discuss this in more detail in the
following sections.

Scala 2.10 provides an extensive reflection API and experimental support for expression macros.
These facilities allow one to do AST transformations on Scala programs using ordinary (macro)
Scala code. Macros are described by the Scala community as a kind of ``lightweight'' plugin
mechanism. Unfortunately at the time of this writing type macros are not available so it is not
yet possible to write a macro that outputs a class definition. However, in the future when type
macros become available it might be possible to implement some or all of Scalaness as a macro
library.

\section{Scala Compiler Organization}

The Scala compiler is organized as a number of phases that rewrite the input in successive steps
lowering it to the target's machine code (JVM bytecode). The precise phases used can be listed
with the command \texttt{scalac -Xshow-phases}. Of primary significance to Scalaness are the
first four phases used by the stock Scala compiler. These phases are shown below.

\singlespace
\begin{Verbatim}
parser
namer
packageobjects
typer
...
\end{Verbatim}
\primaryspacing

The Scalaness plugin injects two new phases into this chain. The \texttt{scalanesstyper} phase
runs after the normal Scala type checking phase (\texttt{typer}). It is in this phase where the
additional type rules of Scalaness are checked and where the Mininess inclusions are type
checked.

In addition the Scalaness plugin injects a \texttt{scalanesspostparser} phase that runs
immediately after the \texttt{parser} phase and before the normal Scala type checking phase.
This phase is responsible for replacing type values with placeholders that will be acceptable to
the Scala type checker. The placeholders are then processed fully by the following
\texttt{scalanesstyper} phase.

One important restriction with the Scala compiler plugin architecture is that plugins are not
able to inject a phase before the parser. Thus any extensions to the Scala language that are
implemented as plugins can not change the raw syntax of Scala programs. Plugins are, however,
able to assign meaning to syntactic structures that are normally semantically invalid.

Another significant restriction is that the three phaes \texttt{namer}, \texttt{packageobjects},
and \texttt{typer} are indivisible. Plugins are not able to inject any new phases between them.
This means that the \texttt{scalanesspostparser} phase has minimal support when deciding which
entities need to be replaced with placeholders.


\section{Component Definition}

Scalaness allows the first stage programmer to manipulate blocks of second stage code written in
a minimal dialect of nesC called \textit{Mininess}. Modules in Mininess can be parameterized by
types and values and instantiated multiple times. These properties are closely modeled by Scala
classes. Thus the representation of a Mininess module in Scalaness is by way of a class that
extends a special marker trait.

One might be tempted to allow a syntax such as

\singlespace
\begin{lstlisting}
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) extends NesCCompont {

  import error_t radio(MessageT *);
  export error_t send( Adt addr, uint8_t *data ) {
    MessageT packet = { self, addr, data };
    radio( &packet );
    return SUCCESS;
  }
}
\end{lstlisting}
\primaryspacing

This defines a Scalaness component using Scala syntax for representing type and value
parameters. The body of the component, however is written in Mininess. Unfortunately this can't
be supported by a compiler plugin because Mininess is too "alien" for the Scala parser to
accept.

One way to work around this is presented in \cite{Garcia-Scala-Query} where the alien language
is included as a string literal. The Scala typer will treat the Mininess program as having type
String but the plugin could parse the string's contents (provided it requires it to be a
literal) and impose additional typing rules on those contents. However, this approach leads to a
rather ungainly programming style:

\singlespace
\begin{lstlisting}
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "import error_t radio(MessageT *);"                +
  "export error_t send( Adt addr, uint8_t *data ) {" +
  "  MessageT packet = { self, addr, data };"        +
  "  radio( &packet );"                              +
  "  return SUCCESS;"                                +
  "}"
}
\end{lstlisting}
\primaryspacing

Instead my implementation uses a string literal to name an external file containing the Mininess
inclusion.

\singlespace
\begin{lstlisting}
class SendC[Adt <: UInt, MessageT <: AbstractMessage[Adt]]
  (self: Adt) {

  "SendC.nc"
}
\end{lstlisting}
\primaryspacing

Conceptually the contents of the named file replace the literal name in the Scalaness program.
However, this approach allows the normal Scala parser and type checker to process the program
successfully. This also allows the programmer to develop the Mininess material in an editor that
is more suitable for nesC. Scalaness programs will, presumably, be developed using a Scala
oriented tool. Such tools will not understand the Mininess inclusion and won't be able to
provide any support for it such as syntax highlighting or automatic indentation.

The Scalaness plugin would, of course, locate the file \filename{SendC.nc}, and parse and
typecheck its contents in the desired way. Notice that, as expected, the scope of the parameters
Adt, MessageT, and self extend to the contents of \filename{SendC.nc}.


\section{Component Operations}

In this section I describe how the Scalaness-level operations on Mininess components are
implemented. There are two basic operations to consider: component composition and component
instantiation.

\subsection{Composition}

\textit{blah, blah, blah}

Before delving into the details of how the conversion to nesC works, I will start with a simple
example. Below is the Scalaness runtime representation of three Mininess components, each as an
instance of class NamedProgramComponent.

\singlespace
\begin{lstlisting}
    val A = new NamedProgramComponent(
      name            = "A",
      typeParameters  = Set(),
      valueParameters = Set(),
      imports         = Set("c1", "c2"),
      exports         = Set())

    val B = new NamedProgramComponent(
      name            = "B",
      typeParameters  = Set(),
      valueParameters = Set(),
      imports         = Set(),
      exports         = Set("c1"))

    val C = new NamedProgramComponent(
      name            = "C",
      typeParameters  = Set(),
      valueParameters = Set(),
      imports         = Set("c1"),
      exports         = Set("c2"))
\end{lstlisting}
\primaryspacing

The parameters, imports, and exports are all represented (for now) as sets of strings. In this
example A uses commands c1 and c2, B provides command c1, etc.

These components can be composed as follows:

\singlespace
\begin{lstlisting}
    val composedComponent1 = A.toProgramComponent + B.toProgramComponent
    val composedComponent2 = composedComponent1 + C.toProgramComponent
    composedComponent2.display(outputFile)
\end{lstlisting}
\primaryspacing

The code above is plain Scala. The Scalaness programmer would use a more convenient syntax but
the compiler, essentially, rewrites that syntax into the above. The first stage program executes
with a Scalaness runtime support library that provides the necessary classes and related
infrastructure to make such code work as intended.

A, B, and C are NamedProgramComponents. These are the components defined by the Scalaness
programmer. Internally, however, all operations on components are done using anonymous
components from class ProgramComponent. I describe the reasons for this more fully below. The
method toProgramComponent is a conversion operator. The method '+' is overloaded here to do
component composition.

In the example above the material that is written to the outputFile is:

\singlespace
\begin{Verbatim}
configuration AppC {
    provides c1;
    provides c2;
}
implementation {
    components A, B, C;
    A.c1 -> B.c1;
    A.c2 -> C.c2;
    C.c1 -> B.c1;
}
\end{Verbatim}
\primaryspacing

There are two kinds of components: those with names and those that are anonymous. Anonymous
components are the result of component composition and can contain a collection of named
components embedded inside of them. The imports and exports of a component are maps that
associate the name of the import or export with the embedded named component that uses or
provides it, respectively. A conversion exists from named to anonymous components. That
conversion returns an anonymous component that has the (one) named component embedded inside of
it.

The types used to represent imports and exports are as shown below.

\singlespace
\begin{lstlisting}
type ImportsType =
  Map[String, List[NamedProgramComponent]]

type ExportsType =
  Map[String, NamedProgramComponent]

type WireType =
  (String, NamedProgramComponent, NamedProgramComponent)
\end{lstlisting}
\primaryspacing

The ImportsType maps an overall import name to a list of NamedProgramComponents because, after
composition the same import might be used by more than one embedded component. That is not the
case for exports since exports are combined with a mutually exclusive map merge. Each overall
export can thus be provided by exactly one embedded component.

The type WireType is used to represent the "wires" between embedded components. It is a triple
where the first element is the name of the command being wired and the other two elements are
the wire endpoints (user first).

In addition each (anonymous) ProgramComponent contains a ProgramConfiguration member. This
configuration describes the embedded components and the nesC wiring used to connect them.

ProgramComponents are immutable instances from the following class

\singlespace
\begin{lstlisting}
class ProgramComponent(
  private val typeParameters: Set[String],
  private val termParameters: Set[String],
  private val imports       : ImportsType,
  private val exports       : ExportsType,
  private val configuration : ProgramConfiguration) { ...
\end{lstlisting}
\primaryspacing

\subsection{Instantiation}

Unfortunately normal Scala class instantiation isn't enough to instantiate Mininess components.
This is because Scalaness allows types to be treated as first class values and such \textit{type
  values} can be used as the type arguments of a Mininess module. To support types as values it
is necessary to introduce a generic class that wraps a representation of a nesC type

\singlespace
\begin{lstlisting}
class MetaType[+Tau <: LiftableTypes.NesCType]
  (val wrappedType: NesCTypes.TypeRepresentation)
    extends LiftableTypes.NesCType
\end{lstlisting}
\primaryspacing

Objects of type \inlinecode{MetaType} contain a representation of a nesC type. They are
covariently parameterized by an upper bound type. Note that \inlinecode{MetaType}'s type
parameter is a Scala type that is liftable to nesC. However the type it wraps is the already
lifted type. Thus \inlinecode{MetaType} objects form a bridge between the Scala and nesC sides
of the system.

A module such as

\singlespace
\begin{lstlisting}
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

Is modified by the Scalaness plugin to hold some additional fields and methods

\singlespace
\begin{lstlisting}
class BlinkC[A <: Int32](period: A) extends NesCComponent {
  /////////
  // Code generated by the Scalaness compiler.
  /////////
  var AType: MetaType[Int32] = null
  def getTypeMap  = Map("A" -> AType)
  def getValueMap = Map("period" -> period)
  ////////
  // END of Scalaness generated code.
  ////////

  "BlinkC.nc"
}
\end{lstlisting}
\primaryspacing

The generated field \inlinecode{AType} holds a reference to the type used to instantiate the
module. In Scalaness this type can only be known at runtime. The methods \inlinecode{getTypeMap}
and \inlinecode{getValueMap} are used during module specialization. The method that does so is
inherited from \inlinecode{NesCComponent} but it calls these methods through their abstract
interface.

Notice that at the Scala level the type parameter must be some type that extends
\inlinecode{LiftableTypes.Int32} (in this example). However, when the module is instantiated the
Scalaness programmer might provide a variable of type \inlinecode{MetaType[Int32]}. For example

\singlespace
\begin{lstlisting}
val desiredType: MetaType[Int32] = ...
val blinkModule = new BlinkC[desiredType](new Int8(100))
\end{lstlisting}
\primaryspacing

The Scala parser will accept this construction but the Scala type checker will reject the use of
a val as a type argument. Thus expressions involving component instantation are rewritten during
the post-parser phases into

\singlespace
\begin{lstlisting}
val blinkModule = {
  val temp = new BlinkC[Int32](new Int8(100))
  temp.AType = desiredType
  temp
}
\end{lstlisting}
\primaryspacing

Unfortunately this rewritting is difficult because of the minimal amount of information
available to the plugin immediately after parsing.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
