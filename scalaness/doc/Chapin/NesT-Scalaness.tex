
\chapter{NesT and Scalaness}
\label{chapter-nest-scalaness}

\section{Scalaness Design}
\label{section-scalaness-design}

\lstset{language=scalaness}
\lstMakeShortInline!

\subsection{Liftable Types}
\label{section-liftable-types-design}

Certain types that appear in a Scalaness program correspond to types in the Mininess components
manipulated by that program. These types are said to be \textit{liftable}. Values of these types
can be computed in the Scalaness program and then used to specialize Mininess components. These
values need to be transformed as they cross the boundary between the two programming languages
in response to differences in the way a liftable type and its Mininess counterpart are
represented. In this section I will describe which Scalaness types are liftable and how their
values are handled when used to specialize a Mininess component.

\subsubsection{Primitive Types}
\label{section-primitive-types-design}

All liftable types are subtypes of a special marker trait !NesCType!. The primitive types in
Mininess have liftable counterparts in Scalaness that are classes extending !NesCType!. These
classes and their corresponding Mininess types are shown in \autoref{table-primitive-liftable}.

\begin{table}
  \centering
  \caption{Primitive Liftable Types}
  \label{table-primitive-liftable}
  \begin{tabular}{|l|l|} \hline
    \textit{Scalaness Type} & \textit{Mininess Type} \\ \hline
    Uninit & void      \\ \hline
    Char   & char      \\ \hline
    UInt32 & uint32\_t \\ \hline
    UInt16 & uint16\_t \\ \hline
    UInt8  & uint8\_t  \\ \hline
    Int32  & int32\_t  \\ \hline
    Int16  & int16\_t  \\ \hline
    Int8   & int8\_t   \\ \hline
  \end{tabular}
\end{table}

The Mininess subtype relations are preserved in Scalaness where !UInt8 <: UInt16 <: UInt32! and
similarly for the signed integer types. In Scalaness these types are defined in the object
!LiftableTypes! so that they don't conflict with any normal (non-liftable) types defined by the
programmer or the language, such as !Char!. Furthermore the integer liftable types are endowed
with the usual arithmetic operations so they can be manipulated in the Scalaness program in a
natural way.

No conversions are provided between the liftable types and their ordinary Scala analogs. This
means existing libraries that, for example, manipulate Scala !Char! objects won't work with
!LiftableTypes.Char!. I do not consider this a problem for two reasons.
\begin{enumerate}
\item Since values of liftable type will eventually be written into Mininess modules, they will
  likely be put to very different uses than values of ordinary Scala type.
\item Conversions (including implicit conversions) can be easily added by the Scalaness
  programmer if desired using the normal facilities of Scala.
\end{enumerate}

To facilitate the second point, explicit conversion methods from each liftable type to its
obvious non-liftable counterpart are provided.

% TODO: The following two paragraphs should be moved to the Scalaness-Implementation section.

The Scala type system is used to ensure compile-time type safety of the primitive liftable types
in a Scalaness program. For example the type !Int16! can only be constructed using a value of
Scala's type !Short!. Consequently normal Scala type checking prevents a potentially out of
range value from being used.

Unfortunately Scala does not support unsigned types natively. In the current implementation a
sufficiently wide signed type is used to initialize objects of unsigned liftable type. This
makes it possible to use an out-of-range value during the execution of the Scalaness program
resulting in a runtime exception. I don't believe this can be avoided without adding support for
unsigned types to the Scala compiler.

\subsubsection{Arrays}
\label{section-arrays-design}

\subsubsection{Structures}
\label{section-structures-design}

A Scala class $C$ that extend the !NesCType! trait is liftable to a Mininess structure type
provided it additionally obeys the following inductive rules.

\begin{enumerate}
\item $C$ is not generic.
\item All of $C$'s fields have liftable type.
\item All of $C$'s supertypes (except !AnyRef! and !ScalaObject!) are liftable types.
\end{enumerate}

In this case $C$ is said to be a \textit{liftable class}. Except for the rules mentioned here
there are no restrictions on the definition or use of liftable classes. In particular, they are
able to have convenience methods, although the methods of a liftable class have no manifestation
in the generated Mininess code.

For example, consider the following Scalaness code:

\singlespace
\begin{lstlisting}[language=scalaness]
class Header
 (val nodeID      : nodeIDType,
  val componentID : UInt8 ) extends NesCType

class TimeStampedHeader
 (val timeStamp   : UInt16) extends Header
\end{lstlisting}
\primaryspacing

Here !nodeIDType! is a previously defined liftable class type. Consequently both of these
classes are liftable and have representations as Mininess structure types. \note{TODO: Figure
  out how to properly model Scala's inheritance system in this context.}

\section{Mininess Design}
\label{section-mininess-design}

\lstset{language=nesC}

The second stage language used by the system described here is a reduced dialect of nesC that I
call Mininess. Unlike full nesC, Mininess is restricted in a way that allows one to make a
stronger statement of the language's type and memory safety. \note{Be specific} In this respect
Mininess closely follows \newterm{nesT}, a theoretical language described in \cite{XXX}.
However, Mininess is not exactly the same as nesT in certain respects. \note{Be specific}

In this chapter I will describe the design of Mininess with a focus on how it differs from nesC
and from nesT. Roughly Mininess is a practical implementation of nesT that can be compiled with
an ordinary nesC compiler.

The description that follows assumes the reader is familiar with nesC.

% TODO: I need to describe the Mininess subset somewhat exhaustively and carefully.

\subsection{Component Specifications}
\label{section-component-specifications-design}

In Mininess components (after specialization) present interfaces that are sequences of imports
and exports. The imports are implemented as nesC commands that are ``used'' by the component and
the exports are implemented as nesC commands that are ``provided'' by the component. NesC-style
events are not part of Mininess but can be simulated using commands.

% TODO: The citation below should really be to the nesC specification.

Mininess does not provide separate interfaces as nesC does. Instead all interaction with other
components is done by way of separately declared commands. These bare commands can be wired
together in the usual way by the nesC compiler \cite{Gay-nesC-2003}. This approach follows nesT
as described in in \cite{FramedML,nesT}. \autoref{figure-example-mininess} shows a simple
example of a Mininess module that interacts with a timer. Instead of using an interface with an
event, the module provides a callback command.

\singlespace
\begin{fpfig}[tbhp]{Example Mininess Module}{figure-example-mininess}
{
\begin{lstlisting}[language=nesC]
module ExampleC {
    uses command void setPeriodic(uint32_t period);
    provides command void fired();
}
implementation {
    // Written in the Mininess subset.
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

A Mininess code base consists of a collection of nesC modules. These modules do not by
themselves constitute a complete program. It is the job of the first stage Scalaness program to
compose Mininess modules, along with supporting components written in full nesC, into full
applications.

Mininess currently does not support nesC-like configuration components, although such support
could be added without significantly changing the system. The Scalaness program that composes
and specializes Mininess modules is responsible for generating the application's top level (and
only) configuration. That configuration defines how the modules are wired together. \note{Say
  something about what happens when Scalaness is used on only a portion of the application}

The only units of Mininess code that Scalaness programs are allowed to manipulate are entire
Mininess modules. The component oriented nature of nesC makes this level of granularity both
sufficient and appropriate. There is no need for the first stage program to manipulate, for
example, individual Mininess functions or Mininess expressions. Also module level granularity is
easier for both the implementation of Scalaness and it's theoretical development. \note{Why?}

Each Mininess module has a nesT module type implied by its specification element list. The
handling of this module type is described in more detail in Section~\ref{XXX}.

\subsection{External Libraries}
\label{section-external-libraries-design}

My experiments with Mininess show that it is expressive enough to write useful program
components. However, any realistic application will need to interact with various libraries
written in full nesC that I call \newterm{external libraries}. It is not my intention to require
the whole program be written in Mininess and generated by Scalaness. These libraries could
represent lower level code such as the TinyOS operating system or represent higher level
application code that wishes to use Scalaness generated Mininess modules.

Neither Mininess nor Scalaness provide any direct support for interfacing to external libraries.
However, a programming technique can be used whereby shim components are manually created that
wrap library interfaces.

As an example, consider the TinyOS \lstinline!Boot! interface. This interface is used to
indicate when a node is started; all useful nesC programs must interact with it. Yet Mininess
does not support interfaces at all much less some of the entities, such as events, that are
commonly declared in nesC interfaces. Instead the programmer creates a shim component such as
\lstinline!BootShimC! as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=nesC]
module BootShimC {
    uses command void booted( );
    uses interface Boot;
}
implementation {
    event void Boot.booted( )
    {
        call booted( );
    }
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The shim component is legal nesC but not legal Mininess. Its purpose is to expose all the
commands and events in an external library interface as bare commands. To this end wrapper
command and event implementations must be manually created.

Although creating shim components is a burden their form is highly stylized. Conceivably a tool
could be created that generates them automatically. A future version of the Scalaness compiler
may perform this function. However, some shim components are complex and must do additional
transformations on command arguments to interface with the non-Mininess external library
commands. In any case, shim components can be reused across Mininess applications. I expect
programmers to accumulate a library of such shims.

The shim components must be wired to the external library components they wrap. This is done by
producing two standard nesC configurations. The first, conventionally called
\lstinline!LibraryIC! encapsulates all full nesC components that have imports. The second,
conventionally called \lstinline!LibraryEC! encapsulates all full nesC components that have
exports. Normally these are the only two configurations an application needs. If the programmer
has full control over the entire application he or she can add the necessary external library
components (via their shims) to either \lstinline!LibraryIC! or \lstinline!LibraryEC! as
appropriate.

For example, \autoref{figure-libraryic} shows an example \lstinline!LibraryIC! component for a
hypothetical application that uses the external \lstinline!MainC! component and a specific
instance of the generic timer module, both from the TinyOS library. \note{Probably need to say
  something more about how generic modules are handled}

\singlespace
\begin{fpfig}[tbhp]{Example LibraryIC configuration}{figure-libraryic}
{
\begin{lstlisting}[language=nesC]
configuration LibraryIC {
    uses command void booted( );
    uses command void fired( );
}
implementation {
    components MainC, BootShimC, SpecificTimerC;

    BootShimC.booted = booted;
    BootShimC.Boot   -> MainC;

    SpecificTimerC.fired = fired;
}
\end{lstlisting}
}
\end{fpfig}
\primaryspacing

Mininess does not (currently) support nesC configurations but Scalaness does allow the component
such as the one shown in \autoref{figure-libraryic} to be declared and manipulated in Scalaness
code. Such components are represented as Scala objects that extend the
\lstinline!MininessComponent! trait as shown below

\singlespace
\vspace{1.0ex}
\begin{lstlisting}[language=scalaness]
object LibraryIC extends MininessComponent {
  external("LibraryIC.nc")
}
\end{lstlisting}
\vspace{1.0ex}
\primaryspacing

The module type of this component can't be determined by examining its nesC definition since it
is not necessarily in the Mininess subset of nesC. Instead the module type on such external
components must be annotated by the programmer as described in XXX, and is accepted without
question by the Scalaness compiler.

In a typical program there are two such objects created, one representing the
\lstinline!LibraryIC! configuration and one representing the \lstinline!LibraryEC!
configuration. These objects are then manipulated in the usual way by the Scalaness program.

Although it is not possible to use Scalaness to compose external library components directly,
the programmer is free to create several different wrapping configurations if desired and
represent each of them separately in the Scalaness program. The Scalaness program could then
dynamically select which wrapping configuration is to be used in the final generated code. In
any case the type system will ensure that illegal wirings can never be made.

\subsection{Safe Casts}
\label{section-safe-casts-design}

Since one of the goals of Mininess is to promote type safety, no implicit converstion operations
are provided. Assignment and initialization from a subtype to a supertype is permitted and
explicit casts are permitted only when configured by the programmer. This allows the programmer
to disallow casts that are unsafe or illogical while also supporting casts that are logical even
if they require non-trivial user defined code to execute.

The Scalaness compiler accepts a configuration file that defines a relation on types
\textit{isCompatible}. If \textit{isCompatible($T_1$, $T_2$)} is true then it is permitted to
cast an expression of type $T_1$ into an expression of type $T_2$. There are no restrictions on
the types $T_1$ and $T_2$.

By giving the developer explicit control over casts, conventional type conversions are permitted
without compromising the logical consistency of the program. Furthermore all such conversions
require explicit cast expressions; they are never applied implicitly.

The implementation of each allowed cast operation is made manifest by a command written by the
developer. This is described more in \autoref{section-safe-casts-implementation}.

\lstDeleteShortInline!

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
