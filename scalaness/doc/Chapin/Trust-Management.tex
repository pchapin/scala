
\chapter{Trust Management}
\label{chapter-trust-management}

Distributed applications that span administrative domains have become commonplace in today's
computing environment. Electronic commerce, high performance scientific computing, groupware,
and multimedia applications all require collaborations between distinct social entities. In such
systems each administrative domain, also called a security domain, controls access to its own
resources and operates independently of other administrative domains. The problem of how to best
specify and implement access control in such an environment has been a topic of considerable
research. To address this problem the concept of trust management was introduced \cite{Blaze:DTM}.

Most existing embedded applications entail only a single administrative domain that owns the
embedded devices. Security in that context is mostly concerned with preventing access by
outsiders. However some applications have been described, such as scenarios involving emergency
response \cite{1038146}, that could easily benefit from a facility that allowed multiple domains
to interact in a controlled manner. As embedded systems in general, and sensor networks in
particular, become more pervasive, situations where multiple domains interact will become more
common. Devices in several domains will then be motivated to use each other's resources in an
effort to increase their efficiency, functionality, or lifetime. Hence the need for fine-grained
application level access control will increase.

At the heart of all trust management systems is the \emph{authorization procedure}, which
determines whether access to a resource should or should not be granted based on a number of
conditions. While a number of techniques have been proposed to characterize authorization in
trust management systems, the most promising are those based on rigorous formal
foundations. This argument is not new, in fact it has motivated trust management research since
its inception \cite{woo93authorizations}. When security is at stake it must be possible to
specify policies in a precise, unambiguous way, and to have confidence that those policies are
correctly enforced. Formally well-founded trust management systems achieve this, providing a
setting in which reliability can be rigorously established by mathematical proof. In particular,
various logics have served as the foundation for trust management
\cite{Abadi:LAC,Bertino:LFRAACM}.

It is important to clearly distinguish between \emph{authorization} and \emph{authentication}.
The latter addresses how to determine or verify the identity of principals in a transaction.
Authorization, on the other hand, is about what the principals are permitted to do once their
identities are known. Although any real implementation of an authorization system will rely on
authentication to establish identities, and key-to-identity bindings may even have an abstract
representation in the system, authorization generally treats authentication and (public) key
infrastructure as orthogonal issues.

Authorization in trust management systems is more expressive than in traditional access control
systems such as role based access control (RBAC) \cite{Sandhu:RBACM}. In those simpler models,
an assumption is made that all principals are known to the authorization procedure a priori.
Access is based on the identities of authenticated principals. But in a distributed environment
creating a single, local database of all potential requesters is untenable. Where there are
multiple domains of administrative control, no single authorizer can be expected to have direct
knowledge of all users of the system. For example, a sensor network owned by a university might
want to provide access not only to the university's students, but also to visiting professors,
guest lecturers, and other entities known to cooperating institutions.

Finally, basing authorization purely on identity is not a sufficiently expressive or flexible
approach, since security in modern distributed systems often utilizes more sophisticated
features (e.g., delegation) and policies (e.g., separation of duty \cite{Simon:SODRBE}). These
issues are addressed by the use of trust management systems.

\section{Components of Trust Management Systems}
\label{section-components}

Trust management systems in practice comprise a number of functions and subsystems, which can be
divided into three major components: \emph{the authorization decision}, \emph{certificate 
storage and retrieval}, and \emph{trust negotiation}. The authorization decision is where the
semantics of the trust management system are made manifest by way of some core logical
structure. Certificate storage and retrieval is relevant to the physical location of
certificates that are representations of access control elements such as credentials and
policies. For example, systems have been proposed for storing SPKI certificates using DNS
\cite{nikander98storing} and for storing SDSI certificates using a peer-to-peer file server
\cite{ajmani02conchord}. Trust negotiation
\cite{Winsborough:ATN,Yu:PECSATNI,Seamons:LDACPATN,Yu:ISATN,Winsborough:TPATN,Winsborough:SATN}
is necessary for access control decisions where some elements of access policies or the
credentials used to prove authorization with those polices should not be arbitrarily disclosed.
For example, in \cite{Winsborough:ATN} a scheme is proposed whereby access rights held by
requesters are protected by their own policies, and both authorizers and requesters must show
compliance with policies during authorization, i.e., they must negotiate.

The importance of these other components notwithstanding, the discussion in this chapter focuses
on authorization decisions. This is because the authorization decision is the basis of any trust
management system. Furthermore, not all the systems proposed in the literature have been
developed sufficiently to include certificate storage implementations or trust negotiation
strategies. Finally, the applications of trust management described in this dissertation do not
use a formal approach for certificate handling nor any trust negotiation.

\subsection{Structure of an Authorization Decision}
\label{section-components-structure}

The authorization decision component of a trust management system includes more than just a core
authorization semantics. The word \emph{system} here is defined as the set of components that provide an
implementation, not just an abstract specification of the authorization semantics. In this
section, the components of a generic authorization decision are identified and its
structure is characterized.

\autoref{figure-tmstruct} illustrates the structure of an authorization decision. This
graphic is meant as a rough sketch, not a formal specification, and not all trust management
systems contain all the components described. The graphic is read from top to bottom, and shows
the flow of information through a particular authorization process, with output computed in
response to an authorization request. The diagram is intentionally vague about the nature of the
output: in the simplest case, the output is a simple ``yes'' or ``no'' decision as to whether or
not to grant resource access, but in systems that support trust negotiation, the output could be
a partial answer that provides direction for additional input. Within the scope of this
dissertation, focus is concentrated on the case where the output is a boolean value, hence the
terminology authorization \emph{decision}. The core authorization semantics $L$ implement the
authorization decision, and may be a specialized inference system, or a proof search in a
generic programming logic such as Prolog, for example. The authorization semantics takes as
input parameters from $C$, $P$, and $Q$, which are now described in detail.

\tmstructfig

Local policy $P$ is defined in some specification language, that is transformed into terms
understood by the core semantics by the transformation function $T_P$. This translation may just
consist of parsing from concrete to abstract syntax, or $T_P$ may compile statements in a
high-level policy language into lower level terms for the core semantics. For example, TPL
\cite{Herzberg:ACMPKI} provides an XML-based ``trust policy language'' that is compiled into
Prolog.

Credentials for a particular requester may be defined as part of local policy. An earmark of
trust management systems, however, is their ability to extend local policies with credentials
conferred by non-local authorities. This is realized as a set of available certificates $C$ that
are transformed by a function $T_C$ into credentials defined in terms understood by the core
semantics. The transformation $T_C$ provides a level of indirection allowing systems to choose
between various certificate wire formats and PKIs such as X.509 \cite{X509} or WS-Security
\cite{OASIS:WSSTC}. When working with resource constrained embedded systems it is desirable to
use certificate formats that are as compact as possible, as described in
\autoref{section-certificate-format}, but that does not affect the behavior of the trust
management system.

The transformation $T_C$ also has special significance for the semantics of trust management
systems, since it is often not a straight parsing or compilation procedure. Rather, certificates
may be rejected, or their credential representations enhanced, by certificate validity
information. Validity information is external to the authorization semantics in some systems,
but internal to it in others, so the certificate validation component of the
authorization decision $V$ is represented as a dashed box.

For example, any given certificate $c \in C$ almost always defines a finite lifetime for the
certification, also called a validity interval \cite{winslett-adl97}. Some trust management
systems such as PCA \cite{Bauer:GFACSW} support lifetime information in the authorization
semantics, and in such a case $T_C$ can map the lifetime information in $c$ to its credential
representation. However, other systems do not represent lifetimes in the authorization semantics
per se (that is, in $L$), and in such cases the onus is on $T_C$ to filter out expired
certificates. For example, SPKI provides a mechanism for certificates to be checked on-line to
see if they have been revoked \cite{RFC-2693}, but this mechanism is not part of SPKI's formal
structure. This means on the one hand SPKI's revocation policy cannot be expressed in the SPKI
policy language itself, nor enforced by its authorization semantics. On the other hand it allows
a SPKI implementation to apply a different revocation policy without changing their underlying
logical structure, and in general the difficulties associated with formalizing certificate
revocation \cite{Stubblebine:RSAERDS,Stubblebine:ALSSRR,Rivest:CWECRL} can be avoided, while a
means for certificate revocation in the system is still available.

In addition to policy $P$ and certificates $C$, the authorization decision takes as input a
question or goal $Q$ that is specialized for a particular access request. As an example, some
trust management systems, such as SDSI and $RT_0$ \cite{Li:DRBTMF,Li:RRBTMF}, define roles.
These systems allow one to prove that a particular principal is in a particular role. Resources
are associated with roles, and the authorization decision is based on whether the requester is a
member of the relevant role. The transformation $T_Q$ translates the goal into terms understood
by the core semantics. Finally, the core semantics combines policies and credentials established
by input certificates to determine whether the authorization goal is satisfied, and outputs
``yes'' or ``no'' based on this determination.

However, as denoted by the dotted line, some systems also provide a ``feedback'' mechanism $D$
between the semantics of authorization and certificate collection. Rather than merely answering
``no'' outright in case an authorization goal cannot be reached, the system might identify
credentials that are missing and attempt to collect them. This functionality is sometimes called
\newterm{distributed certificate chain discovery} \cite{Li:DCDTM} or \newterm{policy directed
  certificate retrieval} \cite{Gunter:PDCR}.

Whatever the specifics, it is clear that this functionality makes for a more flexible system in
terms of certificate distribution and storage, but presents a significant challenge to system
designers, particularly in the embedded case where access to Internet resources may be severely
limited.

\section{Features of Trust Management Systems}
\label{section-features}

This section both describes and discusses a number of features relevant to many trust management
systems and comments on their potential applicability to embedded systems. This is not intended
to be an exhaustive listing, but rather to provide a focus on features that are generally considered
important for trust management applications.

\subsection{Formal Foundation}

Since authorization systems are used in security-sensitive contexts, mathematically precise
descriptions of their behavior and formal assurances of their correctness is essential. A
variety of formalisms serve as effective foundations for the definition of trust management
authorization semantics. The formalisms used can be divided into three main categories: logics,
database formalisms, and graph theory.

In the case of trust management systems based on logic, the authorization problem is expressed
in terms of finding a proof of a particular formula representing successful resource access,
with the policy represented as a collection of suitable axioms. Credentials relevant to a
particular decision become additional hypotheses to be used in the proof. Trust management
systems based on database formalisms (e.g., relational algebra) see the authorization decision
as a query against a distributed database. The certificates issued by a principal contain, in
effect, tuples from relations that a principal controls. Trust management systems based on graph
theory define the authorization decision in terms of finding a path through a graph. The request
is represented by a particular node in the graph. Principals are also graph nodes and the
certificates they issue denote edges.

It is not unusual for a particular trust management system to be described by more than one
formalism. In fact, some aspects of trust management are more naturally expressed using one
formalism or another. Also, \datalog\ serves as both a database formalism and a programming
logic, and several trust management systems, including $RT_0$ that is used in this work, have
been specified in \datalog\ \cite{Li:DCFTML}.

\subsection{Authorization Procedure. Authorization Complexity}

Trust management systems differ in exactly how the authorization decision is implemented. In a
broad sense this is due to differences in the way the systems are described; systems using the
same style of formalization tend to use similar authorization procedures. This is particularly
evident among the systems using programming logics such as \datalog\ as both their formal
foundation and implementation. However, some variations between systems result in significant
differences in how authorization is computed even when the underlying formalism is the same, for
example, if certificate revocation is present in one system but not another. In some cases no
authorization procedure is given; the details of computing authorization is entirely left to the
implementers.

The computational complexity of the authorization decision is clearly of practical interest,
especially to developers of resource constrained systems. Ideally, authorization should be
decidable and tractable, but there is a trade off between the expressiveness of the certificate
and policy language and the complexity of the authorization decision. For example, the systems
that use Datalog with constraints (\datalogc) can have various levels of computational
complexity depending on the constraint domain used \cite{Li:DCFTML}. Yet even trust management
systems with undecidable decision procedures can be potentially useful; realistic policies may
be decidable even if the general policy language is not. Furthermore, practical implementations
can time-out authorization decisions and return a failed access indication in order to avoid
problems with non-termination.

For constrained systems the resources required to make an authorization decision is a matter of
critical importance. Implementing a full Prolog or \datalogc\ interpreter in a small embedded
device would seem to be prohibitively difficult. However, choosing a system that is sufficiently
limited (while still allowing for sufficiently rich access policies) enables various
optimizations that can bring the implementation cost into a reasonable range. This was a major
factor in choosing $RT_0$ for the work described here.

\subsection{Public Key Infrastructure (PKI)}

It is common for trust management systems to treat keys directly as principals. This creates a
conceptually clean design. In contrast, some systems regard the human or machine participants as
the principals and encode a relationship between principals and the keys that identify them. In
the former case, key bindings are not represented in the authorization semantics, whereas in the
latter case they are. Although PKIs underpin the implementation of trust management systems, the
question here is: to what extent does a particular trust management system directly concern
itself with the details of key management?

\subsection{Threshold and Separation of Duty Policies}

Many systems support threshold policies, where at least $k$ out of a set of $n$ entities must
agree on some point in order to grant access. Threshold policies are appealing since agreement
provides confidence in situations wherein no single authority is trusted by itself. The concept
of separation of duty is related to threshold policies. In the case of a separation of duty
policy, entities from different sets must agree before access is granted.

As an example, a bank might require that two different cashiers approve a withdrawal (same
set---threshold policy). The bank might also require that a cashier and a manager, who are not
the same person, approve a loan (different sets---separation of duty policy). In general
threshold policies and separation of duty policies cannot be implemented in terms of each other,
although some trust management systems provide support for both \cite{Li:DRBTMF}.

\subsection{Local Name Spaces}

It is desirable for trust management systems to allow each administrative domain to manage its
own name space independently. Requiring that names be globally unique is problematic and, in
general, infeasible. Although there have been attempts at creating a global name space
\cite{X500}, these attempts have at best only been partially successful. The ability to
reference non-local name spaces is also a keystone of modern trust management, in that it allows
local policy to consider requesters that may not be directly known to the local system.

\subsection{Role-Based Access Control}

In a large system with many principals it is often convenient to use role based access control
(RBAC) \cite{Ferraiolo:RBAC,Sandhu:RBACM}. In such a system \newterm{roles} are used to
associate a group of principals to a set of permissions. The use of roles simplifies
administration since the permissions granted to a potentially large group of principals are
defined in a single place. RBAC is a conceptual foundation of many modern authorization
technologies.

Some trust management systems support RBAC by casting the access control decision as a role
membership decision. Access will be granted if the requester is a member of an appropriate role
but the precise meaning of the roles, in terms of the permissions that are connected to them, is
defined outside the trust management environment. In contrast some trust management systems
include a mechanism in their policy language to define permissions explicitly. In these systems
the access control decision is directly rendered for a particular permission. Finally, in some
cases roles are not provided directly but can be simulated by assigning an appropriate
interpretation to suitable objects within the system.

\subsection{Delegation of Rights}

All trust management systems allow an authorizer to delegate authority. In other words, an
authorizer can specify third parties that have the authority to certify particular attributes. 
This is one of the defining characteristics of a trust management system. However, in many
applications a requester will also want to delegate some or all of his or her rights to an
intermediary who will act on that requester's behalf.

Delegation of rights is important in a distributed environment. For example, a request may be
made to an organization's front end system that accesses internal servers where the request is
ultimately processed. The classic three-tier architecture of web applications follows this
approach. In many environments the back end servers may have their own access control
requirements, in which case the requester will need to delegate his or her rights to the front
end system for use when making requests to the internal servers.

Trust management systems differ in their support for rights delegation. Delegation credentials
may be formally provided, or delegation can be simulated via more primitive forms. Also,
delegation \emph{depth} can be modulated in some systems---rather than being purely transitive,
delegation of rights may only be allowed to be transferred between fixed $n$ principals. In some
cases rights can be delegated arbitrarily or not at all. A system that has this latter feature
is said to support boolean delegation depth.

% Although delegation of rights seems different than delegation of authority, some trust
% management systems can simulate a kind of delegation of rights using delegation of authority.
% To do this the authorizer writes a policy that allows those with access to the resource to
% grant access to others. For example, using the trust management system $RT_0$, the principal
% $A$ can express his willingness to accept delegated rights by writing the policy $A.r
% \leftarrow A.r.s$. Here we assume that a principal must be a member of role $A.r$ to gain
% access. With this policy any principal $E \in A.r$ can create a local role $s$ and add another
% principal $F$ to $E.s$. $F$ then becomes a member of $A.r$ and thus has access to the
% resource. Presumably the lifetime of the certificate issued by $E$ placing $F$ in $E.s$ would
% be short so that the delegation would only be valid for the duration of a single session.
%
% This approach does require an authorizer to write an appropriate policy ahead of time.
% However, even in systems that support delegation of rights as an explicit feature, authorizers
% often have the option of ignoring delegated rights if they choose. Thus it is not unusual for
% this matter to be under the control of the authorizer's policy regardless of the mechanism.
%
% [It seems like the trick I mentioned above requires the TM logic to support circular policy
% statements. I'm not sure that's universal, however. Systems without such an ability might not
% be able to simulate delegation of rights using delegation of authority.]

\subsection{Certificate Validity}

Since an authorizer receives certificates from unknown and potentially untrustworthy entities,
the validity of those certificates must be checked. Usually, signatures must be verified and the
certificate must not have expired, since in practice certificates will almost always have a
finite lifetime in order to ensure that obsolete information cannot circulate indefinitely. In
some systems certificate validity is explicitly treated as part of the structure of the trust
management authorization semantics---the component $L$ described in
\autoref{section-components-structure}. In such cases certificate lifetimes can be directly
represented in credentials and taken into account in policy
\cite{Bauer:GFACSW,lbi-fc01,skalka-wang-chapin-jcs06}.

In other systems, certificate validity is defined externally and checked as part of the
translation of certificates into credentials---the component $T_C$---and not formally reflected
in the authorization semantics \cite{RFC-2693}. Note that it is a topic of debate whether
authorizers \cite{Rivest:CWECRL} or certificate authorities \cite{McDaniel:RTCWECRL} should
determine validity intervals for authorization decisions.

\subsection{Credential Negation}

Policy languages sometimes allow policy makers to specify that a credential \emph{not} be held.
For example, access to a resource may require that requesters not possess a credential endowing
them with a felon role. In systems using logic as a foundation for the semantics of
authorization, this is expressed as credential negation. That is, authorization is predicated on
the negation of a role attribute expressed as a credential. Note that this makes the semantics
nonmonotonic---as more credentials (facts) are added to the system, it is possible that fewer
authorizations succeed. As noted in \cite{seamons-policy02}, this makes credential negation a
generally undesirable feature, since nonmonotonic systems are potentially unsound in practice.
For instance, if a certificate is not discovered due to a network failure, access might be
granted that would otherwise have been denied. In the embedded environments considered here,
this is a major concern.

Monotonicity also allows undecidable (or intractable) authorization logics to be used safely. An
authorizer could simply abort an excessively long running computation and deny access. While
this approach might prevent some legitimate requests from succeeding, in a monotonic system it
remains sound since it would never grant access inappropriately.

\subsection{Certificate Revocation}

Certificate revocation is similar to credential negation, but allows previously granted access
rights to be explicitly eliminated \cite{Rivest:CWECRL}. Like certificate validity, this can be
implemented in the translation $T_C$ from certificates to credentials. For example, in SPKI/SDSI
\cite{RFC-2693} online revocation lists can be defined that filter out revoked certificates
prior to conversion to credentials for the authorization decision. At first glance it may appear
that certificate revocation entails nonmonotonicity. However, it has been demonstrated that
certificate revocation can be encoded monotonically in both the Proof Carrying Authorization
framework \cite{Bauer:GFACSW} and a logic-based PKI infrastructure \cite{lbi-fc01}. The
technique points out a relation between certificate revocation and certificate validity, in that
monotonic revocation can be based on lifetimes and the requirement to renew certificates.
Various high-level approaches to, and nuances of, certificate revocation are discussed in
\cite{Rivest:CWECRL}.

\subsection{Distributed Certificate Chain Discovery}

Where do certificates for a particular access request come from? In common scenarios the
requester presents all relevant certificates when requesting access. It is also easy to imagine
settings in which authorizers maintain local databases of certificates. In fact, these are the
scenarios that are assumed in this work.

More generally, however, certificates could be stored anywhere in the network, as long as the
local system has some way of finding them. Of course, given the potentially enormous number of
certificates on the network, it is necessary to define some means of selectively retrieving only
certificates that might pertain to a particular authorization decision. Formally well founded
techniques for doing distributed certificate chain discovery have been described in
\cite{Li:DCDTM,Gunter:PDCR}.

\section{Foundations of Authorization}
\label{section-foundations}

This dissertation's focus is specifically on trust management systems that use a programming
logic as their formal foundation. This approach has the advantage that a specification of the
system's semantics can also serve, in principle, as its implementation. In addition, programming
logics such as \prolog\ and \datalog\ are a well studied and well understood formalism.

Programming logics provide useful abstractions for authorization semantics. They have served as
target languages for the compilation of higher-level authorization languages
\cite{Li:DCFTML,woo93authorizations}, as well as the foundation for enriched authorization
languages \cite{Li:USSUFOL,Jim:STMSCE,DeTreville:BLBSL,Li:DRBTMF,Li:DLLBADA}, and have been used
for the formalization and study of trust management systems
\cite{Li:USSUFOL,polakow-skalka-plas06}.

Both \prolog\ and \datalog\ are \emph{Horn-Clause} logics, in which all formulae are restricted
to the form $\mbox{\it head} \leftarrow \mbox{\it body}$, where $\leftarrow$ is a right-to-left
implication symbol, $\mbox{\it head}$ is a proposition, and $\mbox{\it body}$ is a conjunction
of propositions. If variables $X$ appear in a rule, the rule is implicitly universally
quantified over those variables. The head of each rule is the consequent of the body. If
$\mbox{\it body}$ is empty then the rule is a \emph{fact}.

As a simple example of how logics can apply in a trust management framework, imagine that
delegation should be transitive. Suppose that $\mathit{delegation}(X, Y)$ is defined to mean
that the rights of $X$ have been delegated to $Y$. Suppose also that $\mathit{cert}(X, Y)$
represents a delegation certificate passing rights directly from $X$ to $Y$. The following Horn
clauses obtain transitivity of delegation:
\begin{mathpar}
\mathit{delegation}(X, Y) \leftarrow \mathit{cert}(X, Y)

\mathit{delegation}(X, Y) \leftarrow \mathit{cert}(X, Z), \, \mathit{delegation}(Z, Y)
\end{mathpar}
Letting $a,b,c,...$ denote constants, the following represents a collection of delegation
certificates:
\begin{mathpar}
\mathit{cert}(a, b)

\mathit{cert}(b, c)

\mathit{cert}(b, d)

\mathit{cert}(c, e)
\end{mathpar}
From these facts and the definition of $\mathit{delegation}$, the query $\mathit{delegation}(a,
e)$ will succeed while $\mathit{delegation}(d, e)$ fails.

Datalog was developed as a query language for databases. It is not a full programming language.
In contrast Prolog is Turing complete and thus more expressive than Datalog. This extra
expressivity is useful in certain contexts. For example, a full-featured authorization logic
called Delegation Logic has been defined as a strict extension of Datalog at a high level, that
is ultimately compiled to Prolog for practical implementation \cite{Li:DLLBADA}.

Nevertheless, Datalog has certain advantages in the authorization setting: the combination of
monotonicity, a bottom-up proof strategy, and Datalog's \newterm{safety condition} (any variable
appearing in the head of a rule must also appear in the body) guarantee program termination in
polynomial time. In contrast, Prolog's top-down proof search can cause non-termination in the
presence of cyclic dependencies. For example, if we added the certificate $\mathit{cert}(e,b)$
to the above fact set, some queries would not terminate. This problem is resolved by
\emph{tabling} as in XSB \cite{xsb-page}, but it has been argued that this solution adds too
much size and complexity to the implementation for authorization decisions in general
\cite{Li:DRBTMF}, and for embedded systems particularly. And while Datalog is not capable of
expressing structured data, Datalog with constraints (\datalogc), a restricted form of
constraint logic programming \cite{jaffar-maher-jlp94}, has been shown sufficiently expressive
for a wide range of trust management idioms \cite{Li:DCFTML}.

\section{The RT Trust Management System}
\label{section-rt}

This section provides a detailed review of the \RT\ family of trust management systems
\cite{Li:DRBTMF}. Focus is on \RT\ because it is the trust management system used in the
demonstration applications. Although the choice of \RT\ was largely arbitrary, it offers
an effective combination of expressivity, ease of use, and efficient implementability. Also
\RT\ has a strong formal foundation based on \datalog\ and its variants.

\RT\ is actually a trust management framework and not a single trust management system. The
systems in the \RT\ framework have varying expressiveness and complexity
\cite{Li:DRBTMF,Li:DCDTM,Li:RRBTMF}. \RT\ stands for ``role based trust management'' because it
uses policy and credential statements to associate principals, called \newterm{entities} in the
\RT\ literature, to roles. The significance of the roles is defined externally. The base
system, $RT_0$, provides credential forms for simple role membership as well as indirection
roles and intersection roles as described below.

$RT_1$ is an extension of $RT_0$ providing parameterized roles. $RT_1^C$ further extends $RT_1$
to allow for the description of structured resources \cite{Li:DCFTML,Li:RRBTMF}. The system
$RT^D$ provides a mechanism to describe the delegation of rights and role activations, and
$RT^T$ provides support for threshold and separation of duty policies. $RT^T$ and $RT^D$ can be
used in combination with $RT_0$, $RT_1$, or $RT_1^C$ to create trust management systems such as
$RT_0^T$, $RT_1^{TD}$, and so forth. A rich complexity analysis has also been developed for the
\RT\ framework for problems beyond simple authorization, e.g., role inclusion and role
membership bounds \cite{Li:BPOCSATM}.

\subsection{Features}

The \RT\ framework represents entities as public keys and does not attempt to formalize the
connection between a key and an identity. The \RT\ framework allows each entity to define roles
in a name space that is local to that entity. An authorizer is expected to associate permissions
with a particular role; to access a resource a requester must prove membership in the role. In
this way the \RT\ framework provides role based access control, but it does not deal with
permissions directly in the trust management logic.

To define a role, an entity issues credentials specifying the role's membership. Some of these
credentials may be a part of private policy, others may be signed by the issuer and made
publicly available as certificates. The overall membership of a role is taken as the union of
the memberships specified by all the defining credentials.

Let $A, B, C, \ldots$ range over entities and let $r, s, t, \ldots$ range over role names. A
role $r$ local to an entity $A$ is denoted by $A.r$. $RT_0$ credentials are of the form
$\cred{A.r}{f}{}$, where $f$ can take on one of four forms to obtain one of four credential
types:
\begin{enumerate}

\item $\cred{A.r}{E}{}$ 

 This form asserts that entity $E$ is a member of role $A.r$.

\item $\cred{A.r}{B.s}{}$ 

  This form asserts that all members of role $B.s$ are members of role $A.r$. Credentials of
  this form can be used to delegate authority over the membership of a role to another entity.

\item $\cred{A.r}{B.s.t}{}$ 

  This form asserts that for each member $E$ of $B.s$, all members of role $E.t$ are members of
  role $A.r$. Credentials of this form can be used to delegate authority over the membership of
  a role to all entities that have the attribute represented by $B.s$. The expression $B.s.t$ is
  called a \emph{linked role}.

\item $\cred{A.r}{f_1 \cap \cdots \cap f_n}{}$
  
  This form asserts that each entity that is a member of all roles $f_1,\ldots, f_n$ is also a
  member of role $A.r$. The expression $f_1 \cap \cdots \cap f_n$ is called an
  \emph{intersection role}.

\end{enumerate}
For all credential forms $\cred{A.r}{f}{}$, the principal $A$ is called the \emph{issuer} of the
credential. A credential is transformed into a certificate when it is signed by the issuer's
private key. Recall that the entities are represented by their public keys directly, i.e., the
$A$ and $E$ in $\cred{A.r}{E}{}$ are public keys.

$RT_1$ enhances $RT_0$ by allowing roles to be parameterized. For example, the second
credential form above is extended to $\cred{A.r(h_1, h_2, \ldots, h_n)}{B.s(k_1, k_2, \ldots,
  k_m)}{}$ where the $h_i$ and $k_j$ are parameters. Role parameters are typed and can be
integers, floating point values, dates and times, enumerations, or finite sets or ranges of
these datatypes. An $RT_1$ credential is \newterm{well formed} if the parameters given to the
roles have the right type and if each variable in the credential appears in the body of that
credential.

As an example of an $RT_1$ credential \cite{Li:DRBTMF}, suppose company $A$ has a policy that
the manager of an entity also evaluates that entity. This can be expressed in $RT_1$ using a
policy statement such as
\begin{displaymath}
\cred{A.\mathit{evaluatorOf}(?Y)}{A.\mathit{managerOf(?Y)}}{}
\end{displaymath}
This policy can't be feasibly expressed in $RT_0$ because the role parameters might take on an
arbitrarily large number of values. In $RT_0$ individual credentials would be needed for each
possible value of the role parameter.

$RT_1^C$ further enhances the expressive power of $RT_1$ by allowing structured constraints to
be applied to role parameters. In addition the restriction on variables only appearing in the
body of a rule is lifted \cite{Li:DCFTML,Li:RRBTMF}. For example, suppose a host $H$ wishes to
grant access to a particular range of TCP ports to those entities that are employed by the
information technology department. The host might have as its local policy:
\begin{displaymath}
\cred{\mathit{Host}.p(\mathit{port} \in
  [1024..2048])}{\mathit{IT}.\mathit{employee}}{}
\end{displaymath}
This example assumes that an entity is granted access to a particular TCP port if that entity is
a member of the $\mathit{Host}.p$ role with the port specified as a parameter.

To accommodate threshold structures, representing agreement between a group of principals, the
system $RT^T$ interprets roles as sets of sets of entities, called \newterm{principal sets}.
These principal sets can be combined with role product operators $\odot$ and $\otimes$.

New credential forms are as follows:

\begin{enumerate}

\item $\cred{A.r}{B_1.r_1 \odot B_2.r_2 \odot \cdots \odot B_k.r_k}{}$ 

  Each principal set $p \in A.r$ is formed by $p = p_1 \cup \cdots \cup p_k$ where each $p_i \in
  B_i.r_i$ for $1 \le i \le k$.

\item $\cred{A.r}{B_1.r_1 \otimes B_2.r_2 \otimes \cdots \otimes B_k.r_k}{}$ 

  Each principal set $p \in A.r$ is formed by $p = p_1 \cup \cdots \cup p_k$ where $p_i \cap p_j
  = \emptyset$ for all $i \ne j$ and $p_i \in B_i.r_i$ for $1 \le i \le k$.

\end{enumerate}

The features introduced by $RT^T$ allow threshold policies and separation of duty policies to
be written \cite{Li:DRBTMF}.

$RT^D$ adds the concepts of role activations and delegations to $RT_0$, via the delegation
credential form $\delcred{A}{B}{\activation{C}{D.r}}$. In this case $A$ delegates to $B$ the
\newterm{role activation} of $\activation{C}{D.r}$. Empowered with this role activation $B$ can
then access whatever facilities $C$ can access from role $D.r$. This presupposes that $A$ has
been delegated the activation $\activation{C}{D.r}$, which holds when $A = C$ and $A$ is a
member of role $D.r$ in the basic case. Hence, delegated activations don't carry any authority
unless there is a chain of delegation credentials where the credential at the head of the chain
was issued by the entity mentioned in the role activation.

While the original \RT\ framework does not support revocation in its policy language, it is
proposed to incorporate revocation \cite{Li:DRBTMF} by leveraging a monotonic approach developed
in \cite{lbi-fc01} based on certificate lifetimes. While lifetimes and the requirement for
freshness are encoded logically, the proposal suggests the use of external certificate
revocation lists to implement verification; this is an interesting example of the possible
interplay between the semantics of authorization per se and components external to them.

A variant of the \RT\ framework has been developed that associates risk values with credentials
\cite{skalka-wang-chapin-jcs06}. These risks are tracked through the authorization process so
that the role membership is parameterized by the total membership risk. The set of risks and
their ordering is left abstract, and can be specialized to a number of applications, e.g., risk
can be defined as remaining certificate lifetime, so that role membership is parameterized by
the minimal lifetime of certificates used for authorization.

Finally $RT+_0$ extends $RT_0$ by adding an integer delegation depth control to most
credential forms \cite{Hong:DDCTMS}, a capability that $RT_0$ lacks. $RT+_0$ delegation depths
limit the delegation of authority by tracking the number of namespaces (administrative domains)
such delegations cross. Delegation depth is also allowed to be unlimited, in which case $RT+_0$
degenerates to $RT_0$.

Although the work presented in this dissertation made use of $RT_0$ exclusively, supporting more
advanced variations of the $RT$ framework, or indeed other trust management systems entirely,
would be an interesting avenue for future development.

\subsection{Example}

Suppose Alice is a cancer patient at a hospital being treated by Bob, a doctor. Alice grants Bob
access to her medical records and also allows Bob to delegate such access to others as he sees
fit.

Bob defines his team as a particular collection of individuals together with the people
supporting them. A person supporting one of Bob's team members becomes a team member herself, so
Bob's definition is open ended and can potentially refer to a large number of people he does not
know directly. Here we assume that Bob's team includes both medical and non-medical personnel,
e.g., other doctors as well as receptionists. Once his team is defined, Bob then delegates his
access to Alice's medical records to only the medical staff on his team and not the
administrative staff.

Suppose further that Bob consults with another doctor, Carol, on Alice's condition. Bob modifies
his policy to add Carol temporarily to his team. Carol orders some blood tests that are then
analyzed by Dave, a lab technician and one of Carol's support people. The policy is intended to
allow Dave to access Alice's medical records so that he may, for instance, input the blood test
results.

Dave signs the test results when he uploads them to the hospital database. He also includes
appropriate credentials so that the database will authorize his access. These credentials must
include
\begin{itemize}

\item Bob has delegated his access to Alice's medical records to people on his team who are
  members of the medical staff.

\item Carol is on Bob's team.

\item If someone is on Bob's team, than any person on their support staff is also on Bob's team.

\item Dave is one of Carol's support people.

\item Dave is a member of the hospital's medical staff.

\end{itemize}
On the basis of these relations, one may deduce that Dave has access to Alice's medical records.

Complex access control scenarios such as this are difficult to express using traditional
methods. Neither Alice nor Bob realize that Dave needs to be granted access to Alice's medical
records. Although Dave's role as one of Carol's support people might be enough to grant him
access to the records of Carol's patients, Dave's relationship to Bob, and hence to Alice, is
indirect; it is Bob's act of adding Carol to his team that causes Dave to gain access to Alice's
records. Observe also that Bob's team policy is recursive. A primary purpose of trust management
systems is to provide language features and authorization semantics that support such complex
policies.

To express this example using \RT\, only the facilities of $RT_0$ are necessary. This shows
that even the simplest member of the \RT\ family can be used to express interesting policy
statements. Alice defines a role \texttt{records} whose members are able to access her medical
records. She creates the policy

\begin{itemize}
\item \texttt{Alice.records} $\leftarrow$ \texttt{Bob}
\item \texttt{Alice.records} $\leftarrow$ \texttt{Bob.alice\_delegates}
\end{itemize}

The first rule grants her doctor, Bob, access to her records. The second rule allows Bob to
further delegate that access by defining the membership of an \texttt{alice\_delegates} role.

Bob's standing policy is

\begin{itemize}
\item \texttt{Bob.team} $\leftarrow$ \texttt{Bob.team.support}
\item \texttt{Bob.alice\_delegates} $\leftarrow$
  \texttt{Hospital.medical\_staff} $\cap$ \texttt{Bob.team}
\end{itemize}

The first rule defines Bob's team as including all the support personnel specified by the
members of his team. In the second rule, Bob uses an intersection role to specify that only the
medical personnel on his team should have access to Alice's medical records.

When Bob consults with Carol he adds \texttt{Bob.team} $\leftarrow$ \texttt{Carol} to his policy
to add Carol, and indirectly all of Carol's support people, to his team.

The only part of Carol's policy relevant to this example places Dave in her \texttt{support}
role: \texttt{Carol.support} $\leftarrow$ \texttt{Dave}. Finally Dave has a credential from the
hospital asserting his membership in the \texttt{medical\_staff} role. $RT_0$ can use these
credentials to prove that Dave is a member of \texttt{Alice.records} and thus able to access
Alice's medical records.

\subsection{Semantics}

The original formal semantics of \RT\ is based on \datalog\ \cite{Li:DRBTMF}. Specifically each
\RT\ credential is translated into a \datalog\ rule. The meaning of a collection of \RT\
credentials is defined in terms of the minimum model of the corresponding \datalog\ program. In
the case of the $RT_1^C$, \datalog\ with constraints is used \cite{Li:DCFTML}.

The translation from $RT_0$ to \datalog\ requires only a single predicate \textit{isMember} to
assert when a particular entity is a member of a particular role. The translation rules are
shown below where \datalog\ variables are shown prefixed with `\textit{?}' to distinguish them
from constants.

\begin{enumerate}

\item $\cred{A.r}{E}{}$

$\textit{isMember}(E, A, r).$

\item $\cred{A.r}{B.s}{}$

$\textit{isMember}(\textit{?x}, A, r) \leftarrow
 \textit{isMember}(\textit{?x}, B, s).$

\item $\cred{A.r}{B.s.t}{}$

$\textit{isMember}(\textit{?x}, A, r) \leftarrow
 \textit{isMember}(\textit{?y}, B, s),
 \textit{isMember}(\textit{?x}, \textit{?y}, t).$

\item $\cred{A.r}{B_1.s_1 \cap \cdots \cap B_n.s_n}{}$

$\textit{isMember}(\textit{?x}, A, r) \leftarrow
 \textit{isMember}(\textit{?x}, B_1, s_1), \ldots,
 \textit{isMember}(\textit{?x}, B_n, s_n).$

\end{enumerate}

The authorizer associates a permission with a particular role, say $A.g$, named the
\newterm{governing role}. Access is granted to an entity $E$ if and only if the \datalog\ query
$\textit{isMember}(E, A, g)$ succeeds.

An alternative set-theory semantics has also been defined for $RT_0$ \cite{Li:DCDTM}. In this
semantics each role $A.r$ is represented as a set of entities $\mbox{rmem}(A.r)$ that are
members of that role. For a given set of credentials $\creds$ these sets are the least sets
satisfying the set of inequalities
\begin{displaymath}
\{ \mbox{rmem}(A.r) \supseteq \mbox{expr}[\mbox{rmem}](e)\,|\,
   A.r \longleftarrow e \in \creds \}
\end{displaymath}
where $\mbox{expr}[\mbox{rmem}](e)$ is the set of entities in a particular role expression $e$.
A \newterm{role expression} includes both linked roles and intersection roles. In particular:
\begin{eqnarray*}
\mbox{expr}[\mbox{rmem}](B)        & = & \{B\}            \\
\mbox{expr}[\mbox{rmem}](A.r)      & = & \mbox{rmem}(A.r) \\
\mbox{expr}[\mbox{rmem}](A.r_1.r_2) & = &
  \bigcup_{B \in\, \mbox{rmem}(A.r_1)} \mbox{rmem}(B.r_2) \\
\mbox{expr}[\mbox{rmem}](f_1 \cap \cdots \cap f_k) & = &
  \bigcap_{1 \le j \le k} \mbox{expr}[\mbox{rmem}](f_j)
\end{eqnarray*}
The set-theory semantics for $RT_0$ was developed primarily to provide theoretical support for
a distributed credential chain discovery algorithm \cite{Li:DCDTM}. The set-theory semantics
facilitate proving soundness and completeness of that algorithm.

\subsection{Implementation}

Li et al.~describe an implementation strategy for $RT_0$ in terms of a construct called a
credential graph $\mathgraph{\creds}$ \cite{Li:DCDTM}. Each node in $\mathgraph{\creds}$
represents a role expression with directed edges corresponding to each credential. In addition,
\newterm{derived edges} are added to represent the indirect relationships between roles that are
introduced by linked roles and intersections. An entity is a member of a role if, and only if,
there exists a path from the entity to the role in $\mathgraph{\creds}$. Li et al.~prove that
credential graphs are sound and complete with respect to the set-theory semantics of $RT_0$.

In addition Li et al.~describe a distributed credential chain discovery algorithm that finds a
path in $\mathgraph{\creds}$ given initially incomplete credentials \cite{Li:DCDTM}. The
algorithm assumes that either the issuer or subject of a credential can be contacted on-line and
queried for more credentials on demand, an assumption that may not be true in an embedded
systems context.

The most straightforward implementation of $RT_0$ is to simply compute the minimum model of the
\datalog\ program implied by the union of policy statements and credentials provided by the
requester. This can be done by updating role memberships repeatedly until a fixed point is
reached, a process that is guaranteed to terminate in time polynomial in the total number of
credentials \cite{Li:DCFTML}.

%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End: 
