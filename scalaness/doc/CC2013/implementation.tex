\section{Implementation}
\label{section-implementation}

Scalaness is implemented as a modification to the open source Scala compiler. Although the Scala
compiler supports a plug-in architecture, Scalaness is not implemented as a plug-in since the
needed modifications to the type checker can only be made by direct modification of the compiler
code. In addition to static type checking, runtime support is needed to support Scalaness module
operations. Also, facilities are required to read nesT modules from the file system and parse
them into ASTs, and to write TinyOS image source code files defined by constructed nesT modules
at \tt{image} invocations. This runtime and nesT parsing and translation support has been added
to \texttt{\small scala-library.jar}.

\subsubsection{State of the implementation.} The implementation currently supports all the run
time features described in this paper, at both the Scalaness and nesT levels. NesT type checking
is fully implemented and integrated into the system. Scalaness type checking has been
implemented on ASTs but is only partially integrated into the compiler. The basic interface to
TinyOS libraries described in \autoref{section-libraries} is supported. Some manual massaging of
the C preprocessor is currently required to compile TinyOS object code from nesC source code
generated by Scalaness programs. A working, non-trivial checksumming sample program is presented
in Appendices; this program generates code that compiles and runs on the TelosB platform.

\subsection{Module Language Syntax}

In order to limit modifications of the Scala compiler and reduce engineering problems in our
proof-of-concept implementation, we have avoided modifying Scala syntax to represent Scalaness
features. Hence, modules are represented as class instances, which must satisfy the following
trait:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  trait NesTModuleT {
    def image(): Unit    // Generates residual nesC program.
    def +>(m: NesTModuleT): NesTModuleT  // Wires this to m.
  }
\end{Verbatim}
This trait is implemented by a \tt{NesTModule} class that provides the appropriate semantics for
wiring and TinyOS image generation, including translation to nesC and file output. This class
also manages parsing and storage of nesT ASTs from source code files, and type checking of nesT
ASTs.

Any particular nesT module definition is a subclass of \tt{NesTModule}. Some subtleties are
involved in supporting first class \emph{generic} modules. Instantiation is implemented by
method call, but since type and value parameters vary per module, particular modules must define
their own parameters and instantiation methods. For example, we would represent the \tt{nodeC}
component definition from \autoref{figure-example} as follows:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  class nodeC extends NesTModule {
    var adt     : MetaType[LiftableType] = _
    var self    : LiftableType = _
    var neighbor: LiftableType = _
    def instantiate(a: MetaType[LiftableType], s: LiftableType, n: LiftableType) =
     { val result = new nodeC; result.adt = a; result.self = s; result.neighbor = n; result }
    "nodeC.nt"
  }
\end{Verbatim}
Although it is currently required to manually define the \tt{instantiate} method and parameter
fields, compiler generation of these definitions is a topic for future work. Note that the types
at which parameters are declared are as general as possible (e.g.~\tt{s} and \tt{n} are not
declared as \tt{uint}s but as \tt{LiftableType}s. Class definitions support the semantics of
Scalaness, not Scalaness type checking (discussed below), and declaring generic parameters at a
maximally general type removes interference related to Scala type checking. Also, note the
string literal \tt{''nodeC.nt''} at the end of the definition. This is the file containing the
nesT source code definition of the module. The Scala compiler has been modified to input and
parse the specified source code when this literal is encountered during the Scala type checking
phase.

Here is an example usage of these constructs, an inlining of the invocation described in
\autoref{example-scalanesssemantics}. In this snippet we assume \tt{scode} has already been
defined appropriately:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  val nodeM = new NodeC
  typedef adt <: uint8 = new MetaType[uint8]()
  val ncode = nodeM.instantiate(adt, 1, 2)
  (ncode +> scode).image()
\end{Verbatim}
Evaluation of this code will generate a TinyOS node image, written in nesC, supporting the
application defined by the wiring of \tt{scode} to \tt{ncode}.

\subsection{Type Annotation and Checking}

Scalaness typing relies on native Scala syntax for terms, specifically Scala annotations are
utilized. Scala annotations allow metadata to be associated with definitions. A module type
annotation is of the form \tt{@ModuleType(\texttt{"}\jmodtcat\texttt{"})}, where the
compiler-defined \tt{ModuleType} class modifies the types of annotated identifiers with the type
$\t$. This modification is effected via a new subclass of the \tt{Type} class, containing a
Scalaness type annotation field. For example, the declarations of \tt{nodeC} and \tt{nodeM}
above would be preceded by such an annotation where $\jmodtcat$ is the type specified in
\autoref{example-nesttyping}, and \tt{ncode} would be annotated with an instance of this type.
Similarly, annotations are required on method parameter and result types, if those methods
expect nesT modules as arguments or return them. E.g.~the \tt{radioC} parameter of the
\tt{nodeSpecialize} method in \autoref{figure-example} would be annotated with the \tt{radioT}
type. These requirements reflect the type discipline in Scalaness as specified in
\autoref{section-scalaness}, which requires module type annotations at these points.

Scalaness type checking has been implemented as an analysis of these annotations during Scala
type checking, piggybacking on that process. When type checking a class that extends
\tt{NesTModule}, the compiler uses its type annotation to perform nesT type checking on the
underlying AST representation of the module. When type checking module operations (i.e.~at
invocations of \tt{instantiate}, \tt{+\!\!>}, or \tt{image}), the Scala compiler has been
modified to examine operand types for Scalaness type annotations, and decorate resultant types
of these operations with new Scalaness annotations reflecting the typing rules in
\autoref{figure-scalanesstyping}. A type checking exception is raised in case this analysis
fails. Scalaness type checking does not modify Scala type checking in any other way, so it is a
conservative extension of Scala typing.

%\begin{verbatim}
%@ModuleType("""{ countType <: UInt32 }
%               < ; >
%               { set_count(x: countType): Void;
%                 configure(): Void }""")
%\end{verbatim}


\subsection{Importing nesC Libraries}
\label{section-libraries}

Our preliminary experiments with nesT show that it is expressive enough to write useful program
components. However, any realistic application will need to interact with various libraries
written in nesC. One library of critical importance is the TinyOS operating system itself. In
short, we allow nesC components to be treated as nesT modules as long as they only \tt{use} or
\tt{provide} commands, which are interpreted as nesT imports and exports. Events can be accessed
through ``shim'' modules provided by the user, since used or provided events are really just
syntactic sugar for provided or used commands respectively. For example, suppose we had the
following nesC interface and module definitions:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  interface I {
     command void c1(int);
     event void e1(int);
  }

  module M { provides interface I; } { ... }
\end{Verbatim}
We can shim this module into the following nesC component, which is just a wrapper over \tt{M},
where $\tt{M.c1}$ is, invoked when $\tt{c1}$ is and $\tt{e1}$ is invoked when $\tt{M}$ signals
$\tt{e1}$:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  configuration LibraryC {
    provides command void c1(int);
    uses command void e1(int);
  }
  implementation { ... }
\end{Verbatim}
Now, the above component can be instantiated in Scalaness by referencing the filename of its
definition:
\begin{Verbatim}[fontfamily=cmtt,fontsize=\scriptsize]
  object LibraryC extends NesCModule { external("LibraryC.nc") }
\end{Verbatim}
Assuming that a nesT module $\mu$ imports a function \tt{c1} and exports a function \tt{e1},
Scalaness can now compose these two, as $\tt{LibraryC} \ltimes \mu$ and $\mu \ltimes
\tt{LibraryC}$. Although we do not currently support importing generic nesC components, this is
a topic for future work, and in the meantime instantiated generic components can be referenced
through shims. Automated generation of shim modules is also an interesting direction for future
work, as we surmise there is a simple and powerful algorithmic technique for shimming nesC
libraries.


%\vspace{1.0ex}
%\begin{Verbatim}[fontsize=\scriptsize]
%module SM {
%   uses interface I;
%   provides command void c1(int);
%   uses command void e1(int);
%}
%implementation {
%   event void I.e(int x) { call e1(x); }
%   command void c1(int x) { call I.c1(x); } 
%}
%
%configuration C {
%  provides command void c1(int);
%   uses command void e1(int);
%}
%implementation {
%   components M, SM;
%   SM.I -> M.I; c1 -> SM.c1; SM.e1 -> e1;
% }
%\end{Verbatim}
%\vspace{1.0ex}

