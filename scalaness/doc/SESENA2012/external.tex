
\section{External Libraries}
\label{section-external-libraries}

Our preliminary experiments with Mininess show that it is expressive
enough to write useful program components. However, any realistic
application will need to interact with various libraries written in
full nesC that we call \newterm{external libraries}. It is not our
intention to require the whole program be generated by Scalaness. One
external library of critical importance is the TinyOS operating system
itself.

We provide for such interaction using an approach we call
\newterm{interface unwrapping}. For example, suppose a component
contains the following uses-provides list. \vspace{1.0ex}
\begin{Verbatim}[fontsize=\small]
             uses interface U;
             provides interface P;
\end{Verbatim}
\vspace{1.0ex}

Although not strictly legal in Mininess we nevertheless allow
specification elements indicating interfaces in Mininess programs.
These interfaces are unwrapped according to the following rules:
\begin{enumerate}
\item When an interface is used, its commands become bare commands
  that are used by the component. Its events become bare commands that
  are provided by the component.
\item When an interface is provided, its commands become bare commands
  that are provided by the component. Its events become bare commands
  that are used by the component.
\end{enumerate}

In all cases Mininess only deals with commands. For example, suppose
\code{U} and \code{P} above are defined as shown in
\autoref{figure-example-interfaces}. These interfaces are unwrapped as
also shown in the figure.

\begin{fpfig}[tbhp]{Example Interfaces with Unwrappings}{figure-example-interfaces}
{
\begin{Verbatim}[commandchars=+\[\], fontsize=\small]
interface U {
  command void Uc(int);
  event   void Ue(int);
}

interface P {
  command void Pc(int);
  event   void Pe(int);
}

+textit[Unwraps to+ldots]

// Unwrapped from "uses interface U"
uses     command void Uc(int);
provides command void Ue(int);

// Unwrapped from "provides interface P"
provides command void Pc(int);
uses     command void Pe(int);
\end{Verbatim}
}
\end{fpfig}

Notice that when using lower level libraries, such as TinyOS,
interfaces would only be used. However, we wish to allow for the
possibility of using Scalaness to create libraries that would be
combined with pre-existing high level code. In that case Mininess
components may wish to provide a previously defined interface to that
code.

It is also necessary to give the Scalaness programmer a way of
specifying which library components will back the used (or provided)
interfaces. The precise components to be incorporated into the final
program are dynamically selected during the execution of the first
stage program. Thus they are declared in the Scalaness code in a
manner similar to the way Mininess components are declared, as
described in \autoref{section-nesc-components}. For example an
external library component named \code{LibraryC} could be declared in
Scalaness as: \vspace{1.0ex}
\begin{Verbatim}[fontsize=\small]
   object LibraryC extends NesCComponent {
     external("LibraryC.nc")
   }
\end{Verbatim}
\vspace{1.0ex}

Generic external components are represented by parameterized
Scalaness classes as previously described.

The Scalaness compiler parses the component specification of the
external component and unwraps the interfaces used and provided by
that component. For each such interface the Scalaness compiler
generates a shim module that forwards Mininess commands to the full
nesC interface. When generic interfaces are used by the external
component these shim modules are themselves generic.

\autoref{figure-shim-modules} shows the shims generated for a library
component \code{LibraryC} that uses interface \code{U} and provides
interface \code{P}.

\begin{fpfig}[tbhp]{Shim Modules}{figure-shim-modules}
{
\begin{Verbatim}[fontsize=\small]
module Sclnss_U1 {
  provides interface U;
  uses     command void Uc(int);
  provides command void Ue(int);
}
implementation {
  command void Ue(int i)
    { signal U.Ue(i); }

  command void U.Uc(int i)
    { call Uc(i); }
}

module Sclnss_P1 {
  uses     interface P;
  provides command void Pc(int i);
  uses     command void Pe(int i);
}
implementation {
  event void P.Pe(int i)
    { call Pe(i); }

  command void Pc(int i)
    { call P.Pc(i); }
}
\end{Verbatim}
}
\end{fpfig}

The precise names used for these components are internal identifiers
generated by Scalaness and are not intended to be used by the
programmer. Instead Scalaness wraps the original library component and
the shims into a configuration as shown in
\autoref{figure-library-configuration}. If the original component was
generic or used generic interfaces, then the wrapping configuration is
also generic so that it properly corresponds to its representation in
Scalaness.

\begin{fpfig}[tbhp]{Configuration Wrapping Library Component}{figure-library-configuration}
{
\begin{Verbatim}[fontsize=\small]
configuration Sclnss_LibraryC {
  uses     command void Uc(int);
  provides command void Ue(int);
  provides command void Pc(int);
  uses     command void Pe(int);
}
implementation {
  components Sclnss_P1, Sclnss_U1, LibraryC;
  LibraryC.U  -> Sclnss_U1;
  Sclnss_P1.P -> LibraryC;

  Sclnss_P1.Pe -> Pe;
  Pc -> Sclnss_P1.Pc;
  
  Sclnss_U1.Uc -> Uc;
  Ue -> Sclnss_U1.Ue;
}
\end{Verbatim}
}
\end{fpfig}

In effect the Scalaness compiler automatically converts an external
library component into a Mininess component that can be manipulated by
the first stage program. The Scalaness compiler extracts a module type
for the component, based on its imports and exports, as usual. The
component can then participate in the process of component composition
allowed by the Scalaness language.

In the current implementation the Scalaness compiler does not attempt
to type check the external library component. Presumably external
components have been previously well tested. In effect, Scalaness
treats them as entirely static; staging is only applied to a portion
of the final application and to its overall configuration.

% So it's possible to use an external generic component that fails for
% certain instantiations and Scalaness won't notice that. Fixing this
% would entail extending the type system to cover full nesC since the
% contents of the external components are \emph{not} Mininess.

As we've described so far each external library component is wrapped
in a separate configuration. However, a programmer could create a
larger configuration of library components manually and then treat
that entire configuration as a single entity inside the Scalaness
program. The choice depends on the amount of control the programmer
wants the first stage program to have on how library components are
specified and composed. In some applications it may make sense for an
entire subsystem of library components to be configured into a single
entity ahead of time. In other applications the programmer may wish to
control library configuration as part of the first stage execution.
