
\section{Implementation}
\label{section-implementation}

In this section we outline our implementation of Scalaness.

The standard Scala compiler is organized as a pipeline of
\textit{phases} that progressively lower Scala source code to JVM
bytecode. The compiler has an architecture that allows plugins to
inject new phases into that pipeline. The new phases have access to
internal compiler artifacts, such as the abstract syntax tree,
generated by the standard phases.

\autoref{figure-compiler-phases} shows the phase structure of the
Scala compiler with the Scalaness plugin activated.

\begin{figure}[htbp]
  \input{Figures/Compiler-Phases}
  \centerline{\raise 1em\box\graph}
  \caption{Scalaness Compiler Phases}
  \label{figure-compiler-phases}
\end{figure}

The Scalaness to Scala conversion phase exists to handle
\code{Typedef} instances that are used as types and type parameters to
Mininess modules. The conversion phase replaces such instances with a
token type that will be acceptable to the Scala type checker.
Additional information about the \code{Typedef} instance is recorded
for later use by the Scalaness type checker.

The Scalaness type checker also parses and type checks the Mininess
code associated with Scala \code{NesCComponent} classes. For each
Mininess module the initial type environment includes the parameters
of the module declared in the Scalaness program. The type checking is
done before specialization; if it succeeds all instances of the module
will be type correct \cite{FramedML}.

The Scalaness type checker phase is also responsible for interface
unwrapping, as described in section
\autoref{section-external-libraries}, and performs additional type
checking of the Scalaness code based on the module types it infers.
Notice that Scalaness type checking is done after Scala type checking.
This simplifies the implementation by allowing the pure Scala parts of
the program to be type checked using the existing, well tested Scala
type checker. Scalaness typing is strictly more precise than Scala
typing; a program that is Scalaness-typable is guaranteed to be
Scala-typable.

Finally a runtime environment, made available through a library jar
file, provides support for component composition. The runtime
environment also performs the actual work of specializing the nesC
code and outputting the residual program.

Progress on the implementation is ongoing. Currently the type checking
of Mininess components, using type and term parameters provided by the
Scalaness program, is complete. Mininess module types are inferred and
are made available to the Scalaness type checker. Interface unwrapping
as described in \autoref{section-external-libraries} is partially
complete. Type checking at the Scalaness level is currently being 
implemented.
